---
layout: default
title: 5단계 - 입력 처리
---

# 5단계: 입력 처리

## 🎯 이 단계에서 배울 것

- 키보드 입력 감지
- InputHandler 클래스 구현
- 쿨다운 시스템
- 현재 조각 찾기

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                           | 설명                                                                                                                     |
| ----------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| **내가 만드는 것**      | **InputHandler** 클래스, **MoveLeft/MoveRight/Rotate** 호출, 쿨다운 로직 | 우리가 정의하는 "어떤 키에 어떤 동작을 붙일지". **입력을 게임 로직에 연결**하는 건 우리 코드.                            |
| **엔진(API)이 주는 것** | **Input.GetKey**, **KeyCode**, **FindObjectOfType**, **Update()**        | Unity가 제공. **키가 눌렸는지**는 **엔진(Input)**이 감지. **FindObjectOfType**은 엔진이 씬에서 컴포넌트를 찾아 주는 API. |

**왜 엔진 것을 쓰나?**  
키보드 입력은 **엔진(Input)**이 감지합니다. 우리는 **Input.GetKey(KeyCode.LeftArrow)** 처럼 "이 키가 눌렸을 때"만 **가져다 쓰고**, "그때 **TetrisBlock의 MoveLeft()를 부른다**"는 **연결**만 만듭니다. **FindObjectOfType**은 "지금 떨어지는 블록이 뭔지" 엔진이 씬에서 찾아 주는 기능을 쓰는 것입니다.

---

## 📝 실습 내용

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**

### 1. InputHandler 클래스 생성

`Assets/Scripts/InputHandler.cs` 생성:

**Unity 에디터에서 설정**:
1. 빈 GameObject 생성 (이름: "InputHandler")
2. `InputHandler` 스크립트 추가
3. 씬에 하나만 있으면 됩니다

```csharp
using UnityEngine;

public class InputHandler : MonoBehaviour
{
    private float moveCooldown = 0.1f;
    private float moveTimer = 0f;
    
    void Update()
    {
        moveTimer += Time.deltaTime;
        
        // 좌우 이동
        if (Input.GetKey(KeyCode.LeftArrow) || Input.GetKey(KeyCode.A))
        {
            if (moveTimer >= moveCooldown)
            {
                MoveLeft();
                moveTimer = 0f;
            }
        }
        
        if (Input.GetKey(KeyCode.RightArrow) || Input.GetKey(KeyCode.D))
        {
            if (moveTimer >= moveCooldown)
            {
                MoveRight();
                moveTimer = 0f;
            }
        }
        
        // 회전
        if (Input.GetKeyDown(KeyCode.UpArrow) || Input.GetKeyDown(KeyCode.W))
        {
            Rotate();
        }
    }
    
    void MoveLeft()
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.MoveLeft();
    }
    
    void MoveRight()
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.MoveRight();
    }
    
    void Rotate()
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.Rotate();
    }
    
    // 빠른 낙하 (Soft Drop) - 아래 화살표 키
    void Update()
    {
        moveTimer += Time.deltaTime;
        
        // 빠른 낙하
        if (Input.GetKey(KeyCode.DownArrow) || Input.GetKey(KeyCode.S))
        {
            TetrisBlock current = FindObjectOfType<TetrisBlock>();
            if (current != null && moveTimer >= moveCooldown)
            {
                current.MoveDown();
                moveTimer = 0f;
            }
        }
        
        // ... 기존 코드 ...
    }
}
```

## 🔗 이전 단계와의 연결

**이 섹션은 실습이 아닙니다.** 따로 할 일이나 체크할 항목은 없습니다. "이 단계가 이전 단계와 어떻게 이어지는지"만 **참고**로 정리한 것이므로, 궁금할 때만 읽으면 됩니다.

이 단계에서는 **4단계에서 만든 TetrisBlock의 이동 함수들**을 사용합니다:
- `MoveLeft()`: 4단계에서 구현
- `MoveRight()`: 4단계에서 구현
- `MoveDown()`: 4단계에서 구현
- `Rotate()`: 4단계에서 구현

**작동 방식**:
1. 사용자가 키를 누름
2. InputHandler가 입력을 감지
3. 현재 TetrisBlock를 찾아서 해당 함수 호출
4. TetrisBlock가 이동/회전 수행

## ⚠️ 실제 구현과의 차이점

**블로그 설명**: 간단하게 이해하기 위해 `FindObjectOfType<TetrisBlock>()`로 현재 블록을 찾는 방식으로 설명합니다.

**실제 구현**:
- 실제 코드에서는 더 효율적인 방법을 사용할 수 있습니다:
  ```csharp
  // 실제 코드에서는 Spawner나 GameController가 현재 블록을 관리할 수 있습니다
  private TetrisBlock currentBlock;
  
  void Update()
  {
      if (currentBlock == null)
          currentBlock = FindObjectOfType<TetrisBlock>();
      
      // 입력 처리...
  }
  ```
- `FindObjectOfType`은 매 프레임마다 호출하면 성능에 영향을 줄 수 있으므로, 한 번 찾아서 캐싱하는 것이 좋습니다
- 실제 프로젝트에서는 Spawner가 현재 블록을 관리하고, InputHandler가 Spawner를 참조하는 구조를 사용할 수 있습니다

**중요**:
- 블로그: 매번 `FindObjectOfType` 호출 (간단한 설명)
- 실제: 한 번 찾아서 변수에 저장 후 재사용 (성능 최적화)

**📌 복기**: **변수**에 한 번 저장해 두고 쓰는 것 = 캐싱. [변수](../참고자료/개념/변수.md)에서 다시 실습해 보세요.

## 💡 이번 단계에서 익히는 개념

- **메소드** = 클래스 안에 들어간 **함수** (이름만 다름).  
  예: `MoveLeft()`, `MoveRight()`, `Rotate()` 는 TetrisBlock 클래스 안의 **메소드**입니다.  
  역할은 "그 클래스의 저장소(위치 등)를 다루는 함수"입니다.

**📌 복기**: **메소드** = 클래스 안의 함수. 한 번에 이해 못했어도 [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                                | 이번 단계와의 연결                                     |
| -------------------------------------------------------- | ------------------------------------------------------ |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md)        | 메소드 = 클래스 안의 함수. 한눈에 정리 + AddScore 실습 |
| [함수](../참고자료/개념/함수.md)                         | 매개변수·반환값. AddNumbers, GetTen 실습               |
| [FindObjectOfType](../참고자료/개념/FindObjectOfType.md) | currentPiece 찾기. 씬에서 컴포넌트 찾는 실습           |

**📐 이 단계 확장 실습** (전용 씬에서 점진적 연습): [5단계 확장 실습 01 - Input과 쿨다운](../참고자료/확장-실습/5단계/01-Input과쿨다운.md)  
→ 단계별 확장 실습 전체 목차: [단계별 확장 실습 (목차)](../참고자료/확장-실습/README.md)

## ✅ 확인 사항

- [ ] 화살표 키로 블록이 이동하는가?
- [ ] WASD 키도 작동하는가?
- [ ] 회전 키가 작동하는가?

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 4단계 - 블록 이동 구현](./4단계-블록-이동-구현.md) | [다음 단계: 6단계 - 행 제거 시스템 →](./6단계-행-제거-시스템.md)
