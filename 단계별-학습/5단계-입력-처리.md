---
layout: default
title: 5단계 - 입력 처리
---
# 5단계: 입력 처리

## 🎯 이 단계에서 배울 것

- 키보드 입력 감지
- InputHandler 클래스 구현
- 쿨다운 시스템
- 현재 조각 찾기

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                           | 설명                                                                                                                    |
| ----------------------- | ------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| **내가 만드는 것**      | **InputHandler** 클래스, **MoveLeft/MoveRight/Rotate** 호출, 쿨다운 로직 | 우리가 정의하는 "어떤 키에 어떤 동작을 붙일지".**입력을 게임 로직에 연결**하는 건 우리 코드.                            |
| **엔진(API)이 주는 것** | **Input.GetKey**, **KeyCode**, **FindObjectOfType**, **Update()**        | Unity가 제공.**키가 눌렸는지**는 **엔진(Input)**이 감지. **FindObjectOfType**은 엔진이 씬에서 컴포넌트를 찾아 주는 API. |

**왜 엔진 것을 쓰나?**
키보드 입력은 **엔진(Input)**이 감지합니다. 우리는 **Input.GetKey(KeyCode.LeftArrow)** 처럼 "이 키가 눌렸을 때"만 **가져다 쓰고**, "그때 **TetrisBlock의 MoveLeft()를 부른다**"는 **연결**만 만듭니다. **FindObjectOfType**은 "지금 떨어지는 블록이 뭔지" 엔진이 씬에서 찾아 주는 기능을 쓰는 것입니다.

---

## 📝 실습 내용

**📐 이번 단계 후 예시 구조 (가이드)**  
입력을 받으려면 **InputHandler** 빈 오브젝트를 씬 **루트**에 두고 스크립트만 붙이면 됩니다. **이 예시로 Hierarchy(위치)를 체크**해 보세요.

```
씬 (Tetris)
├─ Main Camera
├─ GameBoard
├─ Spawner
│  └─ (Spawn Point 등)
├─ InputHandler       ← 여기, 루트 레벨에 추가. 빈 오브젝트 + Input Handler (Script). 연결할 칸 없음.
└─ (기타)
```

InputHandler는 **FindObjectOfType&lt;TetrisBlock&gt;()** 로 지금 떨어지는 블록을 찾아서 MoveLeft 등을 호출합니다. **전체 구조** → [시스템 설계 개요](../참고자료/시스템설계개요.md)

---

**📌 작업 씬 제차 확인 (매 단계 필수)**
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**
**📌 발음**: InputHandler, Inspector, Orthographic 등 → **[영어 용어 발음·표기](../참고자료/영어-용어-발음-표기.md)** (한글 발음만 보셔도 됩니다)

### 0. 5단계 시작 전 점검 (누락 방지)

입력(키보드)으로 블록이 움직이려면 **4단계까지** 아래가 모두 갖춰져 있어야 합니다. 하나라도 빠지면 키를 눌러도 이동이 안 됩니다. **InputHandler를 붙이기 전에** 아래 표를 보고 빠진 것이 없는지 확인하세요.

| 확인 항목       | 필요한 것                                                                                                                                               | 없을 때                                                                |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| **작업 씬**     | 상단 씬 탭이**Tetris**                                                                                                                                  | 1단계 씬 이름 변경 방법대로 Tetris로 변경                              |
| **GameBoard**   | Hierarchy에**GameBoard** 오브젝트, **Game Board (Script)** 붙어 있음 (2단계)                                                                            | TetrisBlock이 gameBoard를 못 찾아 **ValidMove()**에서 에러 → 이동 실패 |
| **Spawner**     | Hierarchy에**Spawner** 오브젝트, **Spawner (Script)** 붙어 있음. **Spawn Point** 연결, **Block Prefab** 연결 (4단계)                                    | Play 시 블록이 스폰되지 않음                                           |
| **블록 프리팹** | 사용하는 프리팹(예: I_Block)**루트** 오브젝트에 **TetrisBlock 스크립트** 붙어 있음. **ValidMove, MoveLeft, MoveRight, MoveDown, Rotate** 구현됨 (4단계) | `FindObjectOfType<TetrisBlock>()`이 null → 키를 눌러도 이동 호출 안 됨 |

**체크 방법**

- **GameBoard**: **[Hierarchy > GameBoard]** 클릭 → **[Inspector > Game Board (Script)]** 있는지
- **Spawner**: **[Hierarchy > Spawner]** 클릭 → **[Inspector > Spawner (Script)]** 에 **Spawn Point**, **Block Prefab** 채워져 있는지
- **블록 프리팹**: **[Project > Assets > Prefabs > I_Block]** (등) 더블클릭 → 프리팹 루트 선택 → **[Inspector > Tetris Block (Script)]** 있는지

위가 모두 맞으면 **아래 "0. 테스트 전 필수 설정"**으로 넘어가서 카메라·보드 확인 후 **1. InputHandler 클래스 생성**을 진행하면 됩니다.

---

### 테스트 전 필수 설정 (카메라·게임 보드 표현)

입력(키보드) 테스트 시 **블록과 보드가 화면에 보여야** 합니다. 4단계까지 진행했는데 **Play 시 아무것도 안 보이거나** 블록이 잘린다면 아래를 설정하세요.

`<span id="테스트-전-필수-설정-카메라게임-보드-표현">`

#### 카메라 세팅

1. **[Hierarchy > Main Camera]** 클릭
2. **[Inspector > Main Camera > Transform]**
   - **Position**: **(5, 10, -10)** — 10×20 보드의 **가로 중앙(5), 세로 중간(10)** 을 바라보고, Z는 음수로 두어 2D 화면 앞에 오도록
   - **Rotation**: **(0, 0, 0)**
3. **[Inspector > Main Camera > Camera]**
   - **Projection**: **Orthographic**(읽는 법: 오소그래픽) (2D 테트리스에 적합)
   - **Size**: **10** ~ **12** — 값이 작을수록 확대, 클수록 넓게 보입니다. **10**이면 세로로 보드가 잘 보이고, **12**면 여백이 더 보입니다.
4. **상단 Game 탭**에서 **Free Aspect** 또는 **16:9** 로 두고 Play → 보드 전체(스폰 위치 포함)가 보이는지 확인

#### 게임 보드의 표현 (보드가 안 보일 때)

2단계에서 만든 **GameBoard**는 **빈 GameObject + 스크립트**라서 **화면에 형태가 없습니다**. 다음 중 하나로 "보드 영역"을 확인할 수 있습니다.

- **위치로 추정**: GameBoard 오브젝트 **Transform Position**이 **(0, 0, 0)** 이면, Unity 월드 좌표로 보드는 **x 0~10, y 0~20** 구간입니다. 카메라가 **(5, 10, -10)**, **Size 10~12**이면 이 구간이 뷰 안에 들어옵니다.
- **선택 사항 — 보드 영역 시각화**:
  1. **GameBoard** 자식으로 **빈 오브젝트** 생성 (이름: BoardArea)
  2. **Sprite Renderer** 또는 **Quad**를 추가해 **0,0** 기준으로 가로 10, 세로 20 크기로 두거나, **Gizmos**로 Scene 뷰에서만 사각형을 그리는 스크립트를 둘 수 있습니다.
     (시각화는 2단계·4단계에서 하지 않아도 되고, **테스트 시 보드 위치만 이해**해도 됩니다. **에셋으로 보드 영역 표시하는 구체적인 단계**는 → [6단계 - 게임 보드 시각화](./6단계-행-제거-시스템.md#game-board-visualization)에서 안내합니다.)

**정리**: 테스트 시 **카메라 Position (5, 10, -10), Orthographic Size 10~12**로 맞추면 스폰 위치 (5, 18) 근처와 보드 전체가 Game 뷰에 들어와서 입력 동작을 확인하기 좋습니다.

---

### 1. InputHandler(읽는 법: 인풋 핸들러) 클래스 생성

`Assets/Scripts/InputHandler.cs` 생성:

1. **[Project > Assets > Scripts]** 선택 → **우클릭** → **Create** → **C# Script** → 이름 **InputHandler**
   - 결과: **[Project > Assets > Scripts > InputHandler.cs]**
2. **[Project > Assets > Scripts > InputHandler.cs]** 더블클릭 → 아래 코드로 **전체 교체** 후 저장 (Ctrl+S)

```csharp
using UnityEngine;

public class InputHandler : MonoBehaviour   // [MonoBehaviour 상속]
{
    private float moveCooldown = 0.1f;   // [우리 멤버]
    private float moveTimer = 0f;         // [우리 멤버]

    void Update()   // [Unity가 호출] 상속받은 메소드 — 매 프레임 엔진이 호출
    {
        moveTimer += Time.deltaTime;   // Time.deltaTime: [Unity 프로퍼티]

        if (Input.GetKey(KeyCode.LeftArrow) || Input.GetKey(KeyCode.A))   // Input.GetKey, KeyCode: [Unity API]
        {
            if (moveTimer >= moveCooldown) { MoveLeft(); moveTimer = 0f; }   // MoveLeft: [우리 메소드]
        }
        if (Input.GetKey(KeyCode.RightArrow) || Input.GetKey(KeyCode.D))
        {
            if (moveTimer >= moveCooldown) { MoveRight(); moveTimer = 0f; }   // MoveRight: [우리 메소드]
        }
        if (Input.GetKey(KeyCode.DownArrow) || Input.GetKey(KeyCode.S))
        {
            TetrisBlock current = FindObjectOfType<TetrisBlock>();   // [Unity API]
            if (current != null && moveTimer >= moveCooldown)
            {
                current.MoveDown();   // MoveDown: [우리 메소드] TetrisBlock 쪽
                moveTimer = 0f;
            }
        }
        if (Input.GetKeyDown(KeyCode.UpArrow) || Input.GetKeyDown(KeyCode.W))   // [Unity API]
        {
            Rotate();   // [우리 메소드]
        }
    }

    void MoveLeft()   // [우리 메소드]
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();   // [Unity API]
        if (current != null) current.MoveLeft();   // MoveLeft: [우리 메소드] TetrisBlock 쪽
    }
    void MoveRight()   // [우리 메소드]
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.MoveRight();
    }
    void Rotate()   // [우리 메소드]
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.Rotate();   // Rotate: [우리 메소드] TetrisBlock 쪽
    }
}
```

#### 씬에 InputHandler 연결하는 방법

**개념: InputHandler는 씬의 "어디"에 넣는가**

- InputHandler는 **화면에 보이는 오브젝트가 아닙니다**. 카메라나 블록처럼 위치·크기가 있는 게 아니라, **"키 입력을 감지해서 TetrisBlock에 전달하는"** 역할만 하는 스크립트를 담는 **빈 오브젝트**입니다.
- 그래서 **Hierarchy에서 어느 부모 아래에 두든**, **Transform 위치가 어디든**, 입력 동작에는 영향이 없습니다. 씬에 **한 번만** 있으면 됩니다.
- 다만 씬을 정리하기 위해 보통 **GameBoard, Spawner, Main Camera와 같은 "루트 레벨"** 에 둡니다. 즉, **다른 오브젝트의 자식으로 넣지 않고**, Hierarchy **맨 위쪽(부모 없음)** 에 두는 방식을 씁니다.

**씬에서의 위치 (Hierarchy 구조 예)**

- **Hierarchy**에서 **빈 곳을 우클릭** → **Create Empty**를 하면, 새 오브젝트는 **부모가 없는 "루트"** 로 만들어집니다. Main Camera, GameBoard, Spawner와 **같은 최상위 레벨**에 추가됩니다.
- InputHandler는 **그 루트 레벨에 두면 됩니다.** GameBoard나 Spawner **안(자식)** 에 넣지 않습니다.

예시 구조:

```
Hierarchy
├── Main Camera
├── GameBoard
├── Spawner
│   └── (Spawn Point 등)
├── InputHandler   ← 여기, 루트 레벨에 추가
└── (기타)
```

**연결 과정 (순서대로)**

1. **빈 오브젝트 만들기****[Hierarchy]** 빈 공간(다른 오브젝트 이름이 아닌 곳) **우클릭** → **Create Empty**.→ 새 오브젝트가 **루트 레벨**에 **GameObject**로 생김 (위치: **[Hierarchy > GameObject]**).
2. **이름 바꾸기**방금 생긴 오브젝트 선택 후 **F2** 또는 **[Inspector]** 맨 위 **이름** 칸에서 **InputHandler** 로 입력 후 **Enter**.→ 결과: **[Hierarchy > InputHandler]**.
3. **InputHandler 스크립트 붙이기 (드래그)****[Project > Assets > Scripts > InputHandler.cs]** 를 **클릭한 채로** 잡아서**[Hierarchy > InputHandler]** 위로 **드래그**하여 놓기.→ **[Inspector > InputHandler > Input Handler (Script)]** 가 보이면 연결된 것.
4. **확인****[Hierarchy > InputHandler]** 클릭 시 **[Inspector > Input Handler (Script)]** 가 보이면 씬에 제대로 연결된 것.InputHandler는 Spawner와 달리 **연결할 칸**(Spawn Point, Block Prefab)이 없고, 스크립트만 붙이면 됨.
5. **씬 저장**
   **Ctrl+S**를 누르거나 **File** → **Save**를 선택해서 씬을 저장한다.
   저장하지 않으면 나중에 씬을 다시 열었을 때 InputHandler 오브젝트가 없을 수 있다.

**정리**: **[Hierarchy]** 루트에 **InputHandler** 빈 오브젝트 생성 → **[Project > Assets > Scripts > InputHandler.cs]** 를 **[Hierarchy > InputHandler]** 위로 **드래그** → **Ctrl+S**로 씬 저장. (위치 표기 규칙: [1단계 - 위치 표기 규칙](./1단계-Unity-기초.md#location-tree-notation))

---

#### 언제 스폰된 블록이 움직이나요?

코드만 넣으면 “언제 이동이 되는 거지?” 싶을 수 있습니다. **이동은 Play 모드에서** 아래처럼 일어납니다.

1. **▶ Play를 눌러야 합니다.**에디터에서 **Play**를 누르면 게임이 실행되고, 그때부터 Spawner가 블록을 하나 스폰하고, 아래 동작이 돌아갑니다.
2. **자동 낙하 (이미 4단계에서)**스폰된 블록에 붙어 있는 **TetrisBlock**의 **Update()**가 **매 프레임** 실행됩니다.그 안에서 `fallTimer`가 쌓이고, **fallSpeed**(기본 1초)마다 **MoveDown()**이 호출됩니다.그래서 **키를 안 눌러도** 스폰된 블록이 **저절로 아래로 한 칸씩** 내려갑니다.
3. **키로 이동 (이번 5단계에서)**
   **InputHandler**의 **Update()**도 매 프레임 실행됩니다.
   사용자가 **화살표 키 또는 WASD**를 누르면, InputHandler가 `FindObjectOfType<TetrisBlock>()`로 **지금 씬에 있는 스폰된 블록**을 찾고, **MoveLeft()**, **MoveRight()**, **Rotate()**, **MoveDown()**을 호출합니다.
   그래서 **키를 누르는 순간** 스폰된 블록이 **그 방향으로** 움직입니다.

**정리**: 코딩만 한 것이 아니라, **Play를 누른 뒤**

- **자동 낙하** = TetrisBlock의 Update() → fallTimer → MoveDown()
- **키 입력** = InputHandler의 Update() → 키 감지 → TetrisBlock의 MoveLeft() 등 호출
  으로 **스폰된 블록이 자동으로 떨어지고, 키를 누르면 좌우·회전·빠른 낙하**가 됩니다.

#### 키를 눌러도 이동이 안 될 때 (떨어지는 건 나중에 하고, 좌우·회전부터 확인)

**Play를 눌렀는데 화살표/WASD를 눌러도 스폰된 블록이 안 움직이면** 아래를 순서대로 확인하세요.

1. **Game 뷰에 포커스가 있는지****Game** 뷰 탭을 **한 번 클릭**해서 포커스를 줍니다. Inspector나 다른 창에 포커스가 있으면 키 입력이 게임에 전달되지 않습니다.
2. **InputHandler가 씬에 있는지****[Hierarchy > InputHandler]** 가 있고, **[Inspector > Input Handler (Script)]** 가 붙어 있는지 확인. 없으면 입력을 받는 쪽이 없음.
3. **스폰된 블록(프리팹) 루트에 TetrisBlock이 붙어 있는지**Spawner가 스폰하는 건 **블록 프리팹의 루트** 오브젝트입니다. `FindObjectOfType<TetrisBlock>()`은 씬에 있는 **TetrisBlock 컴포넌트** 하나를 찾습니다.→ **프리팹을 열어서**, 루트 오브젝트(예: I_Block)에 **TetrisBlock 스크립트**가 붙어 있어야 합니다. 자식 큐브에만 붙어 있고 루트에 없으면 찾지 못해서 이동이 호출되지 않습니다.
4. **GameBoard가 씬에 있는지****TetrisBlock**은 **Start()**에서 `FindObjectOfType<GameBoard>()`로 GameBoard를 찾습니다. **Hierarchy**에 **GameBoard** 오브젝트가 있고 **Game Board (Script)** 가 붙어 있어야 합니다.GameBoard가 없으면 **gameBoard**가 null이고, **ValidMove()** 안에서 **gameBoard.width** 접근 시 **NullReferenceException**이 나서 이동이 실패합니다. **Console**에 빨간 에러가 뜨는지 확인하세요.
5. **Console에 에러가 있는지**
   **Window → General → Console**에서 빨간 에러가 있으면, 그 메시지를 보고 위 3·4를 다시 확인합니다. (예: NullReferenceException: Object reference not set to an instance of an object → gameBoard나 current가 null인 경우가 많음.)

**정리**: 이동이 안 되면 **Game 뷰 포커스** → **InputHandler·GameBoard가 씬에 있는지** → **블록 프리팹 루트에 TetrisBlock** → **Console 에러** 순으로 확인하면 됩니다.

#### 나중에 블록이 여러 개 나오나요?

**네. 나중에 나옵니다.**

- **지금(4·5단계)**: Spawner는 **Start()**에서 **블록 한 개만** 스폰합니다. 그래서 Play하면 블록 하나만 떨어집니다.
- **6단계에서**: 블록이 바닥에 닿으면 **LockPiece()**가 호출되고, 그 안에서 **Spawner.SpawnNext()**를 부릅니다. 그래서 **한 블록이 고정될 때마다 다음 블록**이 스폰됩니다. 한 번에 하나씩 떨어지고, 고정되면 그다음 블록이 나오는 식으로 이어집니다.
- **8단계에서**: Spawner에 **프리팹 배열**과 **랜덤 선택**을 넣으면 **블록 종류**(I, O, T 등)가 여러 개 나오게 할 수 있습니다.

**정리**: 6단계에서 **LockPiece() → SpawnNext()** 로 이어지면 블록이 **차례로** 나오고, 8단계에서 **여러 종류**의 블록이 나오게 할 수 있습니다.

---

## 🔗 이전 단계와의 연결

**이 섹션은 실습이 아닙니다.** 따로 할 일이나 체크할 항목은 없습니다. "이 단계가 이전 단계와 어떻게 이어지는지"만 **참고**로 정리한 것이므로, 궁금할 때만 읽으면 됩니다.

이 단계에서는 **4단계에서 만든 TetrisBlock의 이동 함수들**을 사용합니다:

- `MoveLeft()`: 4단계에서 구현
- `MoveRight()`: 4단계에서 구현
- `MoveDown()`: 4단계에서 구현
- `Rotate()`: 4단계에서 구현

**작동 방식**:

1. 사용자가 키를 누름
2. InputHandler가 입력을 감지
3. 현재 TetrisBlock를 찾아서 해당 함수 호출
4. TetrisBlock가 이동/회전 수행

## ⚠️ 실제 구현과의 차이점

**블로그 설명**: 간단하게 이해하기 위해 `FindObjectOfType<TetrisBlock>()`로 현재 블록을 찾는 방식으로 설명합니다.

**실제 구현**:

- 실제 코드에서는 더 효율적인 방법을 사용할 수 있습니다:
  ```csharp
  // 실제 코드에서는 Spawner나 GameController가 현재 블록을 관리할 수 있습니다
  private TetrisBlock currentBlock;

  void Update()
  {
      if (currentBlock == null)
          currentBlock = FindObjectOfType<TetrisBlock>();

      // 입력 처리...
  }
  ```
- `FindObjectOfType`은 매 프레임마다 호출하면 성능에 영향을 줄 수 있으므로, 한 번 찾아서 캐싱하는 것이 좋습니다
- 실제 프로젝트에서는 Spawner가 현재 블록을 관리하고, InputHandler가 Spawner를 참조하는 구조를 사용할 수 있습니다

**중요**:

- 블로그: 매번 `FindObjectOfType` 호출 (간단한 설명)
- 실제: 한 번 찾아서 변수에 저장 후 재사용 (성능 최적화)

**📌 복기**: **변수**에 한 번 저장해 두고 쓰는 것 = 캐싱. [변수](../참고자료/개념/변수.md)에서 다시 실습해 보세요.

## 💡 이번 단계에서 익히는 개념

- **메소드** = 클래스 안에 들어간 **함수** (이름만 다름).
  예: `MoveLeft()`, `MoveRight()`, `Rotate()` 는 TetrisBlock 클래스 안의 **메소드**입니다.
  역할은 "그 클래스의 저장소(위치 등)를 다루는 함수"입니다.

**📌 복기**: **메소드** = 클래스 안의 함수. 한 번에 이해 못했어도 [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                                | 이번 단계와의 연결                                     |
| -------------------------------------------------------- | ------------------------------------------------------ |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md)        | 메소드 = 클래스 안의 함수. 한눈에 정리 + AddScore 실습 |
| [함수](../참고자료/개념/함수.md)                         | 매개변수·반환값. AddNumbers, GetTen 실습               |
| [FindObjectOfType](../참고자료/개념/FindObjectOfType.md) | currentPiece 찾기. 씬에서 컴포넌트 찾는 실습           |

**📐 이 단계 확장 실습** (전용 씬에서 점진적 연습): [5단계 확장 실습 01 - Input과 쿨다운](../참고자료/확장-실습/5단계/01-Input과쿨다운.md)
→ 단계별 확장 실습 전체 목차: [단계별 확장 실습 (목차)](../참고자료/확장-실습/README.md)

## ✅ 확인 사항

- [ ] **시작 전 점검**: 위 **0. 5단계 시작 전 점검**에서 GameBoard, Spawner, 블록 프리팹(루트에 TetrisBlock)이 모두 갖춰져 있는가?
- [ ] **테스트 전 설정**: **테스트 전 필수 설정 (카메라·게임 보드 표현)** 을 적용했는가? (블록이 안 보이면 카메라 Position/Size 확인)
- [ ] 화살표 키로 블록이 이동하는가?
- [ ] WASD 키도 작동하는가?
- [ ] 회전 키가 작동하는가?
- [ ] 아래 화살표(또는 S)로 빠른 낙하가 작동하는가?

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 4단계 - 블록 이동 구현](./4단계-블록-이동-구현.md) | [다음 단계: 6단계 - 행 제거 시스템 →](./6단계-행-제거-시스템.md)
