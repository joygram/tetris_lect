---
layout: default
title: 5단계 - 입력 처리
---

# 5단계: 입력 처리

## 🎯 이 단계에서 배울 것

- 키보드 입력 감지
- InputHandler 클래스 구현
- 쿨다운 시스템
- 현재 조각 찾기

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                           | 설명                                                                                                                     |
| ----------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| **내가 만드는 것**      | **InputHandler** 클래스, **MoveLeft/MoveRight/Rotate** 호출, 쿨다운 로직 | 우리가 정의하는 "어떤 키에 어떤 동작을 붙일지". **입력을 게임 로직에 연결**하는 건 우리 코드.                            |
| **엔진(API)이 주는 것** | **Input.GetKey**, **KeyCode**, **FindObjectOfType**, **Update()**        | Unity가 제공. **키가 눌렸는지**는 **엔진(Input)**이 감지. **FindObjectOfType**은 엔진이 씬에서 컴포넌트를 찾아 주는 API. |

**왜 엔진 것을 쓰나?**  
키보드 입력은 **엔진(Input)**이 감지합니다. 우리는 **Input.GetKey(KeyCode.LeftArrow)** 처럼 "이 키가 눌렸을 때"만 **가져다 쓰고**, "그때 **TetrisBlock의 MoveLeft()를 부른다**"는 **연결**만 만듭니다. **FindObjectOfType**은 "지금 떨어지는 블록이 뭔지" 엔진이 씬에서 찾아 주는 기능을 쓰는 것입니다.

---

## 📝 실습 내용

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**

### 0. 테스트 전 필수 설정 (카메라·게임 보드 표현)

입력(키보드) 테스트 시 **블록과 보드가 화면에 보여야** 합니다. 4단계까지 진행했는데 **Play 시 아무것도 안 보이거나** 블록이 잘린다면 아래를 설정하세요.

<span id="테스트-전-필수-설정-카메라게임-보드-표현"></span>

#### 카메라 세팅

1. **Hierarchy**에서 **Main Camera** 선택  
2. **Inspector**에서 **Transform**  
   - **Position**: **(5, 10, -10)** — 10×20 보드의 **가로 중앙(5), 세로 중간(10)** 을 바라보고, Z는 음수로 두어 2D 화면 앞에 오도록  
   - **Rotation**: **(0, 0, 0)**  
3. **Camera** 컴포넌트  
   - **Projection**: **Orthographic** (2D 테트리스에 적합)  
   - **Size**: **10** ~ **12** — 값이 작을수록 확대, 클수록 넓게 보입니다. **10**이면 세로로 보드가 잘 보이고, **12**면 여백이 더 보입니다.  
4. **Game** 뷰에서 **Free Aspect** 또는 **16:9** 등으로 두고 Play → 보드 전체(스폰 위치 포함)가 보이는지 확인

#### 게임 보드의 표현 (보드가 안 보일 때)

2단계에서 만든 **GameBoard**는 **빈 GameObject + 스크립트**라서 **화면에 형태가 없습니다**. 다음 중 하나로 "보드 영역"을 확인할 수 있습니다.

- **위치로 추정**: GameBoard 오브젝트 **Transform Position**이 **(0, 0, 0)** 이면, Unity 월드 좌표로 보드는 **x 0~10, y 0~20** 구간입니다. 카메라가 **(5, 10, -10)**, **Size 10~12**이면 이 구간이 뷰 안에 들어옵니다.  
- **선택 사항 — 보드 영역 시각화**:  
  1. **GameBoard** 자식으로 **빈 오브젝트** 생성 (이름: BoardArea)  
  2. **Sprite Renderer** 또는 **Quad**를 추가해 **0,0** 기준으로 가로 10, 세로 20 크기로 두거나, **Gizmos**로 Scene 뷰에서만 사각형을 그리는 스크립트를 둘 수 있습니다.  
  (시각화는 2단계·4단계에서 하지 않아도 되고, **테스트 시 보드 위치만 이해**해도 됩니다. **에셋으로 보드 영역 표시하는 구체적인 단계**는 → [6단계 - 게임 보드 시각화](./6단계-행-제거-시스템.md#game-board-visualization)에서 안내합니다.)

**정리**: 테스트 시 **카메라 Position (5, 10, -10), Orthographic Size 10~12**로 맞추면 스폰 위치 (5, 18) 근처와 보드 전체가 Game 뷰에 들어와서 입력 동작을 확인하기 좋습니다.

---

### 1. InputHandler 클래스 생성

`Assets/Scripts/InputHandler.cs` 생성:

**Unity 에디터에서 설정**:
1. 빈 GameObject 생성 (이름: "InputHandler")
2. `InputHandler` 스크립트 추가
3. 씬에 하나만 있으면 됩니다

```csharp
using UnityEngine;

public class InputHandler : MonoBehaviour
{
    private float moveCooldown = 0.1f;
    private float moveTimer = 0f;
    
    void Update()
    {
        moveTimer += Time.deltaTime;
        
        // 좌우 이동
        if (Input.GetKey(KeyCode.LeftArrow) || Input.GetKey(KeyCode.A))
        {
            if (moveTimer >= moveCooldown)
            {
                MoveLeft();
                moveTimer = 0f;
            }
        }
        
        if (Input.GetKey(KeyCode.RightArrow) || Input.GetKey(KeyCode.D))
        {
            if (moveTimer >= moveCooldown)
            {
                MoveRight();
                moveTimer = 0f;
            }
        }
        
        // 빠른 낙하 (Soft Drop) — 아래 화살표 키
        if (Input.GetKey(KeyCode.DownArrow) || Input.GetKey(KeyCode.S))
        {
            TetrisBlock current = FindObjectOfType<TetrisBlock>();
            if (current != null && moveTimer >= moveCooldown)
            {
                current.MoveDown();
                moveTimer = 0f;
            }
        }
        
        // 회전
        if (Input.GetKeyDown(KeyCode.UpArrow) || Input.GetKeyDown(KeyCode.W))
        {
            Rotate();
        }
    }
    
    void MoveLeft()
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.MoveLeft();
    }
    
    void MoveRight()
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.MoveRight();
    }
    
    void Rotate()
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();
        if (current != null) current.Rotate();
    }
}
```

## 🔗 이전 단계와의 연결

**이 섹션은 실습이 아닙니다.** 따로 할 일이나 체크할 항목은 없습니다. "이 단계가 이전 단계와 어떻게 이어지는지"만 **참고**로 정리한 것이므로, 궁금할 때만 읽으면 됩니다.

이 단계에서는 **4단계에서 만든 TetrisBlock의 이동 함수들**을 사용합니다:
- `MoveLeft()`: 4단계에서 구현
- `MoveRight()`: 4단계에서 구현
- `MoveDown()`: 4단계에서 구현
- `Rotate()`: 4단계에서 구현

**작동 방식**:
1. 사용자가 키를 누름
2. InputHandler가 입력을 감지
3. 현재 TetrisBlock를 찾아서 해당 함수 호출
4. TetrisBlock가 이동/회전 수행

## ⚠️ 실제 구현과의 차이점

**블로그 설명**: 간단하게 이해하기 위해 `FindObjectOfType<TetrisBlock>()`로 현재 블록을 찾는 방식으로 설명합니다.

**실제 구현**:
- 실제 코드에서는 더 효율적인 방법을 사용할 수 있습니다:
  ```csharp
  // 실제 코드에서는 Spawner나 GameController가 현재 블록을 관리할 수 있습니다
  private TetrisBlock currentBlock;
  
  void Update()
  {
      if (currentBlock == null)
          currentBlock = FindObjectOfType<TetrisBlock>();
      
      // 입력 처리...
  }
  ```
- `FindObjectOfType`은 매 프레임마다 호출하면 성능에 영향을 줄 수 있으므로, 한 번 찾아서 캐싱하는 것이 좋습니다
- 실제 프로젝트에서는 Spawner가 현재 블록을 관리하고, InputHandler가 Spawner를 참조하는 구조를 사용할 수 있습니다

**중요**:
- 블로그: 매번 `FindObjectOfType` 호출 (간단한 설명)
- 실제: 한 번 찾아서 변수에 저장 후 재사용 (성능 최적화)

**📌 복기**: **변수**에 한 번 저장해 두고 쓰는 것 = 캐싱. [변수](../참고자료/개념/변수.md)에서 다시 실습해 보세요.

## 💡 이번 단계에서 익히는 개념

- **메소드** = 클래스 안에 들어간 **함수** (이름만 다름).  
  예: `MoveLeft()`, `MoveRight()`, `Rotate()` 는 TetrisBlock 클래스 안의 **메소드**입니다.  
  역할은 "그 클래스의 저장소(위치 등)를 다루는 함수"입니다.

**📌 복기**: **메소드** = 클래스 안의 함수. 한 번에 이해 못했어도 [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                                | 이번 단계와의 연결                                     |
| -------------------------------------------------------- | ------------------------------------------------------ |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md)        | 메소드 = 클래스 안의 함수. 한눈에 정리 + AddScore 실습 |
| [함수](../참고자료/개념/함수.md)                         | 매개변수·반환값. AddNumbers, GetTen 실습               |
| [FindObjectOfType](../참고자료/개념/FindObjectOfType.md) | currentPiece 찾기. 씬에서 컴포넌트 찾는 실습           |

**📐 이 단계 확장 실습** (전용 씬에서 점진적 연습): [5단계 확장 실습 01 - Input과 쿨다운](../참고자료/확장-실습/5단계/01-Input과쿨다운.md)  
→ 단계별 확장 실습 전체 목차: [단계별 확장 실습 (목차)](../참고자료/확장-실습/README.md)

## ✅ 확인 사항

- [ ] **테스트 전 설정**: 위 **0. 테스트 전 필수 설정 (카메라·게임 보드 표현)** 을 적용했는가? (블록이 안 보이면 카메라 Position/Size 확인)
- [ ] 화살표 키로 블록이 이동하는가?
- [ ] WASD 키도 작동하는가?
- [ ] 회전 키가 작동하는가?
- [ ] 아래 화살표(또는 S)로 빠른 낙하가 작동하는가?

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 4단계 - 블록 이동 구현](./4단계-블록-이동-구현.md) | [다음 단계: 6단계 - 행 제거 시스템 →](./6단계-행-제거-시스템.md)
