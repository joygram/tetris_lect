---
layout: default
title: 6단계 - 행 제거 시스템
---

# 6단계: 행 제거 시스템

## 🎯 이 단계에서 배울 것

- 가득 찬 행 감지
- 행 제거 로직
- 위 블록들을 아래로 이동
- 점수 계산

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                                         | 설명                                                                                                                                    |
| ----------------------- | -------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **내가 만드는 것**      | **GameBoard.AddToGrid**, **ClearFullRows**, **TetrisBlock.LockPiece**                  | 우리가 정의하는 "블록을 어디에 고정할지", "가득 찬 행을 어떻게 지우고 위 블록을 내릴지". **테트리스 규칙** 전부 우리 로직.              |
| **엔진(API)이 주는 것** | **Transform**, **SetParent**, **GetChild**, **Mathf.RoundToInt**, **FindObjectOfType** | Unity가 제공. **부모 바꾸기(SetParent)**, **자식 접근(GetChild)** 는 엔진 기능. 우리는 "**언제** 고정하고 **어느 칸**에 넣을지"만 정함. |

**왜 엔진 것을 쓰나?**  
오브젝트의 부모를 바꾸고, 자식 순서를 읽는 건 **엔진(Transform)** 이 하는 일입니다. 우리는 **그리드(grid)** 에 "어느 칸에 뭐가 있는지"를 우리 방식으로 저장하고, **언제 행을 지우고, 어떻게 점수를 넘길지**만 만듭니다. **FindObjectOfType**으로 GameController를 찾는 것도 "씬에 있는 걸 엔진이 찾아 주는 API"를 쓰는 것입니다.

---

## 📝 실습 내용

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**

### 1. 블록을 보드에 고정하는 함수

먼저 블록이 더 이상 내려갈 수 없을 때 보드에 저장하는 함수를 추가합니다:

`GameBoard.cs`에 추가:

```csharp
// 블록을 그리드에 추가 (고정)
// 참고 블로그 방식: 자식 블록들을 직접 사용
public void AddToGrid(TetrisBlock block)
{
    // 모든 자식 블록 확인
    for (int i = 0; i < block.transform.childCount; i++)
    {
        Transform child = block.transform.GetChild(i);
        
        // 자식 블록의 Unity 월드 좌표를 정수로 반올림
        int roundX = Mathf.RoundToInt(child.position.x);
        int roundY = Mathf.RoundToInt(child.position.y);
        
        // 보드 범위 확인
        if (roundX >= 0 && roundX < width && roundY >= 0 && roundY < height)
        {
            // 부모를 GameBoard로 변경 (고정된 블록이므로)
            child.SetParent(transform);
            
            // 그리드에 저장
            grid[roundX, roundY] = child;
        }
    }
}
```

**작동 방식**:
1. TetrisBlock의 모든 자식 블록(Block_0, Block_1 등)을 확인
2. 각 블록의 Unity 월드 좌표를 `Mathf.RoundToInt()`로 정수로 변환
3. 부모를 GameBoard로 변경 (고정된 블록이므로)
4. 그리드 배열에 저장

**📌 복기**: **배열** = grid[,]에 칸을 순서대로 저장. [배열](../참고자료/개념/배열.md)에서 다시 실습해 보세요.

### 2. TetrisBlock에 블록 고정 함수 추가

`TetrisBlock.cs`에 추가:

```csharp
public void LockPiece()
{
    // GameBoard에 블록 추가
    if (gameBoard != null)
    {
        gameBoard.AddToGrid(this);
        
        // 행 제거 확인
        int linesCleared = gameBoard.ClearFullRows();
        
        // 점수 추가 (7단계에서 GameController 연결)
        GameController gameController = FindObjectOfType<GameController>();
        if (gameController != null)
        {
            gameController.AddScore(linesCleared);
        }
        
        // 다음 블록 생성 (8단계에서 Spawner 연결)
        Spawner spawner = FindObjectOfType<Spawner>();
        if (spawner != null)
        {
            spawner.SpawnNext();
        }
    }
    
    // 현재 TetrisBlock 부모 오브젝트 삭제 (자식은 이미 GameBoard로 이동됨)
    Destroy(gameObject);
}
```

### 3. MoveDown 함수 수정

4단계에서 만든 `MoveDown()` 함수를 수정합니다:

```csharp
public void MoveDown()
{
    if (ValidMove(Vector3.down))
    {
        transform.position += Vector3.down;
    }
    else
    {
        // 더 이상 내려갈 수 없으면 블록 고정
        LockPiece();
    }
}
```

### 4. 행 제거 함수 구현

`GameBoard.cs`에 추가:

```csharp
public void ClearFullRows()
{
    for (int y = 0; y < height; y++)
    {
        if (IsRowFull(y))
        {
            ClearRow(y);
            MoveRowsDown(y);
            y--;  // 다시 확인
        }
    }
}

bool IsRowFull(int row)
{
    for (int x = 0; x < width; x++)
    {
        if (grid[x, row] == null)
            return false;
    }
    return true;
}

void ClearRow(int row)
{
    for (int x = 0; x < width; x++)
    {
        if (grid[x, row] != null)
        {
            Destroy(grid[x, row].gameObject);
            grid[x, row] = null;
        }
    }
}

void MoveRowsDown(int clearedRow)
{
    // 위의 행들을 아래로 이동
    for (int y = clearedRow + 1; y < height; y++)
    {
        for (int x = 0; x < width; x++)
        {
            if (grid[x, y] != null)
            {
                // 한 칸 아래로 이동
                grid[x, y - 1] = grid[x, y];
                grid[x, y] = null;
                
                // 시각적 위치도 업데이트
                grid[x, y - 1].position += Vector3.down;
            }
        }
    }
}

// 제거한 행 개수를 반환하도록 수정
public int ClearFullRows()
{
    int linesCleared = 0;
    
    for (int y = 0; y < height; y++)
    {
        if (IsRowFull(y))
        {
            ClearRow(y);
            MoveRowsDown(y);
            y--;  // 다시 확인 (한 칸 아래로 내려왔으므로)
            linesCleared++;
        }
    }
    
    return linesCleared;
}
```

## 🔗 이전 단계와의 연결

이 단계에서는:
- **3단계의 프리팹**: 자식 블록들을 직접 사용 (`transform.GetChild()`)
- **4단계의 `MoveDown()`**: 블록이 더 이상 내려갈 수 없을 때 `LockPiece()` 호출
- **2단계의 `GameBoard`**: 그리드에 블록 저장 및 행 제거
- **7단계의 `GameController`**: 행 제거 개수를 받아서 점수 계산

**작동 흐름**:
1. 블록이 바닥에 닿음 → `MoveDown()`에서 `LockPiece()` 호출
2. `LockPiece()` → `gameBoard.AddToGrid()`로 자식 블록들을 그리드에 저장
3. `gameBoard.ClearFullRows()` → 가득 찬 행 제거
4. 제거한 행 개수 반환 → GameController에서 점수로 변환

**참고 블로그 방식의 특징**:
- 자식 블록을 `transform.GetChild()`로 직접 접근
- Unity 좌표를 `Mathf.RoundToInt()`로 정수로 변환
- 부모를 GameBoard로 변경하여 고정

## 📺 UI 준비하기 (7단계에서 자세히 설명)

행을 제거하면 점수가 올라갑니다. 점수를 화면에 표시하려면 UI가 필요합니다.

**7단계에서 UI를 만들 예정이지만, 미리 만들어두고 싶다면:**

1. **Canvas 생성** (아직 없다면)
   - Hierarchy 창의 빈 공간에서 **우클릭**
   - **"UI"** → **"Canvas"** 선택

2. **점수 표시 Text 생성**
   - Hierarchy에서 **"Canvas"** 클릭
   - Canvas 선택 상태에서 Hierarchy 창에서 **우클릭**
   - **"UI"** → **"Text - TextMeshPro"** 또는 **"UI"** → **"Legacy"** → **"Text"** 선택
   - 이름을 **"ScoreText"**로 변경
   - Inspector에서:
     - **Text**: "Score: 0" 입력
     - **Font Size**: 24
     - **Color**: 흰색
   - **Rect Transform**:
     - **Pos X**: 400, **Pos Y**: 200
     - **Width**: 200, **Height**: 50

3. **줄 수 표시 Text 생성**
   - Canvas 선택 후 **우클릭** → **"UI > Text - TextMeshPro"** 또는 **"UI > Legacy > Text"**
   - 이름을 **"LinesText"**로 변경
   - Inspector에서:
     - **Text**: "Lines: 0" 입력
     - **Font Size**: 24
     - **Color**: 흰색
   - **Rect Transform**:
     - **Pos X**: 400, **Pos Y**: 150
     - **Width**: 200, **Height**: 50

**참고**: 
- UI 연결은 7단계에서 GameController와 함께 설명합니다
- 지금은 행 제거 로직에 집중하세요!

## 💡 이번 단계에서 익히는 개념

- **멤버** = 클래스 안에 들어간 **변수** (저장소).  
  예: GameBoard의 `grid`, TetrisBlock의 `position`, `cells` 는 **멤버**입니다.  
  **메소드**는 이 멤버를 읽거나 바꾸는 함수입니다 (예: `AddToGrid`, `ClearFullRows`).

**📌 복기**: **변수**(멤버) + 그걸 다루는 **메소드**. 한 번에 이해 못했어도 [변수](../참고자료/개념/변수.md) · [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                         | 이번 단계와의 연결                                            |
| ------------------------------------------------- | ------------------------------------------------------------- |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md) | 멤버 = 클래스 안 변수, 메소드 = 그걸 다루는 함수. 한눈에 정리 |
| [반복문](../참고자료/개념/반복문.md)              | for로 행 순회, foreach로 셀 순회. for·foreach 실습            |
| [배열](../참고자료/개념/배열.md)                  | grid[,] 2차원 배열. 2차원 배열 읽고 쓰기 실습                 |
| [충돌 감지](../참고자료/개념/충돌감지.md)         | IsCellEmpty, 범위 확인. CanMoveTo 실습                        |

## ✅ 확인 사항

- [ ] 한 줄을 채우면 제거되는가?
- [ ] 위 블록들이 아래로 내려오는가?
- [ ] 여러 줄을 동시에 제거할 수 있는가?

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 5단계 - 입력 처리](./5단계-입력-처리.md) | [다음 단계: 7단계 - 점수 및 레벨 시스템 →](./7단계-점수-레벨-시스템.md)
