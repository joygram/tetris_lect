---
layout: default
title: 6단계 - 행 제거 시스템
---

# 6단계: 행 제거 시스템

## 🎯 이 단계에서 배울 것

- **게임 보드 시각화** (보드 영역을 화면에 표시 — 블록이 쌓이고 행이 지워지는 모습을 보기 위해)
- 가득 찬 행 감지
- 행 제거 로직
- 위 블록들을 아래로 이동
- 점수 계산

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                                         | 설명                                                                                                                                    |
| ----------------------- | -------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **내가 만드는 것**      | **GameBoard.AddToGrid**, **ClearFullRows**, **TetrisBlock.LockPiece**                  | 우리가 정의하는 "블록을 어디에 고정할지", "가득 찬 행을 어떻게 지우고 위 블록을 내릴지". **테트리스 규칙** 전부 우리 로직.              |
| **엔진(API)이 주는 것** | **Transform**, **SetParent**, **GetChild**, **Mathf.RoundToInt**, **FindObjectOfType** | Unity가 제공. **부모 바꾸기(SetParent)**, **자식 접근(GetChild)** 는 엔진 기능. 우리는 "**언제** 고정하고 **어느 칸**에 넣을지"만 정함. |

**왜 엔진 것을 쓰나?**  
오브젝트의 부모를 바꾸고, 자식 순서를 읽는 건 **엔진(Transform)** 이 하는 일입니다. 우리는 **그리드(grid)** 에 "어느 칸에 뭐가 있는지"를 우리 방식으로 저장하고, **언제 행을 지우고, 어떻게 점수를 넘길지**만 만듭니다. **FindObjectOfType**으로 GameController를 찾는 것도 "씬에 있는 걸 엔진이 찾아 주는 API"를 쓰는 것입니다.

---

## 📝 실습 내용

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**

### 0. 게임 보드 시각화 (권장 — 실습이 덜 지루해집니다) {#game-board-visualization}

2단계에서 만든 **GameBoard**는 **빈 GameObject + 스크립트**라서 **화면에 형태가 없습니다**. 이대로면 블록이 쌓이고 행이 지워지는 모습을 보기 어렵고, 실습이 지루해질 수 있습니다. **6단계에서** 보드 영역을 화면에 표시해 두면, 이후 **행 제거·점수**를 확인하기 훨씬 수월합니다.

보드 영역을 **코드로 그리면**(Gizmos, 라인 등) 이해하기 부담될 수 있으므로, **에셋으로 배경을 넣는 방법** 하나만 소개합니다. **스크립트 수정 없이** 에디터에서 에셋과 오브젝트만 설정하면 됩니다.

---

#### 에셋으로 보드 영역 표시 (스프라이트 1개)

**Game 뷰**에서 보드가 **사각형 배경**으로 보이게 합니다. **코드는 쓰지 않고**, 에셋 + 오브젝트 배치만 합니다.

1. **스프라이트 에셋 만들기**  
   - **Project** 창에서 보드용 이미지를 넣을 폴더 선택 (예: Assets, 또는 **Create > Folder**로 `Sprites` 폴더 생성)  
   - **우클릭** → **Create** → **2D** → **Sprites** → **Square**  
   - 생성된 **Square**가 보드 배경용 스프라이트입니다. (이미지 툴로 만든 1×1 픽셀 흰/회색 이미지를 Import해 써도 됩니다.)

2. **보드 배경 오브젝트 만들기**  
   - **Hierarchy**에서 **GameBoard** 선택 → **우클릭** → **Create Empty**  
   - 이름: **BoardBackground**

3. **Sprite Renderer 추가**  
   - **BoardBackground** 선택 → **Inspector**에서 **Add Component**  
   - **Sprite Renderer** 검색 후 추가

4. **스프라이트 연결**  
   - **Sprite Renderer**의 **Sprite** 칸(맨 위 "None")을 클릭  
   - **Project**에서 방금 만든 **Square**를 선택해 넣거나, **Square**를 **Sprite** 칸으로 드래그

5. **Transform 설정** (GameBoard가 Position (0, 0, 0)일 때 기준)  
   - **Position**: **(5, 10, 0)** — 10×20 보드의 가로 중앙(5), 세로 중간(10)  
   - **Rotation**: **(0, 0, 0)**  
   - **Scale**: **(10, 20, 1)** — 보드 전체를 한 번에 덮는 크기

6. **색상·정렬** (선택)  
   - **Sprite Renderer**의 **Color**를 **어두운 회색** 등으로 바꾸면 블록과 구분하기 좋습니다.  
   - **Sorting Layer** / **Order in Layer**를 블록보다 **작은 값**으로 두면 배경이 블록 뒤에 그려집니다.

**정리**: 에셋(Square 스프라이트) 1개 + BoardBackground 오브젝트 + Sprite Renderer 설정만으로 보드 영역이 Game 뷰에 보입니다. 스크립트 수정은 필요 없습니다.

**📷 카메라 위치·조정** (고정된 이유, 에디터에서 수정이 안 될 때) → [카메라 설정 가이드](../참고자료/카메라-설정-가이드.md)

---


### 1. 블록을 보드에 고정하는 함수

먼저 블록이 더 이상 내려갈 수 없을 때 보드에 저장하는 함수를 추가합니다:

`GameBoard.cs`에 추가:

```csharp
// 블록을 그리드에 추가 (고정)
// 참고 블로그 방식: 자식 블록들을 직접 사용
public void AddToGrid(TetrisBlock block)
{
    // 모든 자식 블록 확인
    for (int i = 0; i < block.transform.childCount; i++)
    {
        Transform child = block.transform.GetChild(i);
        
        // 자식 블록의 Unity 월드 좌표를 정수로 반올림
        int roundX = Mathf.RoundToInt(child.position.x);
        int roundY = Mathf.RoundToInt(child.position.y);
        
        // 보드 범위 확인
        if (roundX >= 0 && roundX < width && roundY >= 0 && roundY < height)
        {
            // 부모를 GameBoard로 변경 (고정된 블록이므로)
            child.SetParent(transform);
            
            // 그리드에 저장
            grid[roundX, roundY] = child;
        }
    }
}
```

**작동 방식**:
1. TetrisBlock의 모든 자식 블록(Block_0, Block_1 등)을 확인
2. 각 블록의 Unity 월드 좌표를 `Mathf.RoundToInt()`로 정수로 변환
3. 부모를 GameBoard로 변경 (고정된 블록이므로)
4. 그리드 배열에 저장

**📌 복기**: **배열** = grid[,]에 칸을 순서대로 저장. [배열](../참고자료/개념/배열.md)에서 다시 실습해 보세요.

### 2. TetrisBlock에 블록 고정 함수 추가

`TetrisBlock.cs`에 추가:

```csharp
public void LockPiece()
{
    // GameBoard에 블록 추가
    if (gameBoard != null)
    {
        gameBoard.AddToGrid(this);
        
        // 행 제거 확인
        int linesCleared = gameBoard.ClearFullRows();
        
        // 점수 추가 (7단계에서 GameController 연결)
        GameController gameController = FindObjectOfType<GameController>();
        if (gameController != null)
        {
            gameController.AddScore(linesCleared);
        }
        
        // 다음 블록 생성 (8단계에서 Spawner 연결)
        Spawner spawner = FindObjectOfType<Spawner>();
        if (spawner != null)
        {
            spawner.SpawnNext();
        }
    }
    
    // 현재 TetrisBlock 부모 오브젝트 삭제 (자식은 이미 GameBoard로 이동됨)
    Destroy(gameObject);
}
```

### 3. MoveDown 함수 수정

4단계에서 만든 `MoveDown()` 함수를 수정합니다:

```csharp
public void MoveDown()
{
    if (ValidMove(Vector3.down))
    {
        transform.position += Vector3.down;
    }
    else
    {
        // 더 이상 내려갈 수 없으면 블록 고정
        LockPiece();
    }
}
```

### 4. 행 제거 함수 구현

#### 행 제거 개념 (코드 전에 이해하기)

**행 제거**란 **가로 한 줄이 블록으로 꽉 찼을 때**, 그 줄을 없애고 **그 위에 있던 블록들을 한 칸씩 아래로 내리는** 동작입니다. 테트리스의 핵심 규칙 중 하나입니다.

**동작 순서 (개념)**  
1. **가득 찬 행 찾기** — 보드에서 “가로 한 줄이 전부 블록인지” 확인합니다.  
2. **그 행 지우기** — 해당 줄의 블록을 없애고, 그리드에서도 비웁니다.  
3. **위 블록들 내리기** — 지운 줄 **위쪽**에 있던 모든 블록을 **한 칸씩 아래**로 옮깁니다. (화면에서도 한 칸씩 내려가야 하므로 `position += Vector3.down`로 옮깁니다.)

**아래에서 위로 확인하는 이유**  
- y=0(맨 아래)부터 y=19(맨 위)까지 순서대로 검사합니다.  
- 한 행을 지우고 위 행들을 내리면, **그 자리(y)에 새로 내려온 행**이 채워집니다. 그래서 **같은 y를 한 번 더 검사**해야 합니다. `y--`는 “한 칸 아래로 내려왔으니 같은 y를 다시 보자”는 뜻입니다.

**예시 (개념)**  
- 지우기 전: 5번째 행(y=5)이 가득 참. 그 위 6, 7, 8… 행에는 블록이 있음.  
- 5번째 행 지우기 → 6번째 행이 5번째 자리로, 7번째 행이 6번째 자리로… 한 칸씩 내려옴.  
- 그 다음에도 “지금 5번째 행이 가득 찬가?”를 다시 확인해야 하므로, for문에서 `y--`로 같은 y를 다시 검사합니다.

**코드와의 대응**  
- `IsRowFull(y)` = “y번째 행이 가득 찬가?”  
- `ClearRow(y)` = “y번째 행의 블록 지우기”  
- `MoveRowsDown(y)` = “y 위쪽 행들을 한 칸씩 아래로 이동”

---

**📌 "한 행이 가득 찼는지"만 먼저 연습하고 싶다면** → [6단계 확장 실습 01 - 그리드와 행 검사](../참고자료/확장-실습/6단계/01-그리드와행검사.md)

---

`GameBoard.cs`에 추가:

```csharp
public void ClearFullRows()
{
    for (int y = 0; y < height; y++)
    {
        if (IsRowFull(y))
        {
            ClearRow(y);
            MoveRowsDown(y);
            y--;  // 다시 확인
        }
    }
}

bool IsRowFull(int row)
{
    for (int x = 0; x < width; x++)
    {
        if (grid[x, row] == null)
            return false;
    }
    return true;
}

void ClearRow(int row)
{
    for (int x = 0; x < width; x++)
    {
        if (grid[x, row] != null)
        {
            Destroy(grid[x, row].gameObject);
            grid[x, row] = null;
        }
    }
}

void MoveRowsDown(int clearedRow)
{
    // 위의 행들을 아래로 이동
    for (int y = clearedRow + 1; y < height; y++)
    {
        for (int x = 0; x < width; x++)
        {
            if (grid[x, y] != null)
            {
                // 한 칸 아래로 이동
                grid[x, y - 1] = grid[x, y];
                grid[x, y] = null;
                
                // 시각적 위치도 업데이트
                grid[x, y - 1].position += Vector3.down;
            }
        }
    }
}

// 제거한 행 개수를 반환하도록 수정
public int ClearFullRows()
{
    int linesCleared = 0;
    
    for (int y = 0; y < height; y++)
    {
        if (IsRowFull(y))
        {
            ClearRow(y);
            MoveRowsDown(y);
            y--;  // 다시 확인 (한 칸 아래로 내려왔으므로)
            linesCleared++;
        }
    }
    
    return linesCleared;
}
```

## 🔗 이전 단계와의 연결

**이 섹션은 실습이 아닙니다.** 따로 할 일이나 체크할 항목은 없습니다. "이 단계가 이전 단계와 어떻게 이어지는지"만 **참고**로 정리한 것이므로, 궁금할 때만 읽으면 됩니다.

이 단계에서는:
- **3단계의 프리팹**: 자식 블록들을 직접 사용 (`transform.GetChild()`)
- **4단계의 `MoveDown()`**: 블록이 더 이상 내려갈 수 없을 때 `LockPiece()` 호출
- **2단계의 `GameBoard`**: 그리드에 블록 저장 및 행 제거
- **7단계의 `GameController`**: 행 제거 개수를 받아서 점수 계산

**작동 흐름**:
1. 블록이 바닥에 닿음 → `MoveDown()`에서 `LockPiece()` 호출
2. `LockPiece()` → `gameBoard.AddToGrid()`로 자식 블록들을 그리드에 저장
3. `gameBoard.ClearFullRows()` → 가득 찬 행 제거
4. 제거한 행 개수 반환 → GameController에서 점수로 변환

**참고 블로그 방식의 특징**:
- 자식 블록을 `transform.GetChild()`로 직접 접근
- Unity 좌표를 `Mathf.RoundToInt()`로 정수로 변환
- 부모를 GameBoard로 변경하여 고정

## 📺 UI 준비하기 (7단계에서 자세히 설명)

행을 제거하면 점수가 올라갑니다. 점수를 화면에 표시하려면 UI가 필요합니다.

**7단계에서 UI를 만들 예정이지만, 미리 만들어두고 싶다면:**

1. **Canvas 생성** (아직 없다면)
   - Hierarchy 창의 빈 공간에서 **우클릭**
   - **"UI"** → **"Canvas"** 선택

2. **점수 표시 Text 생성**
   - Hierarchy에서 **"Canvas"** 클릭
   - Canvas 선택 상태에서 Hierarchy 창에서 **우클릭**
   - **"UI"** → **"Text - TextMeshPro"** 또는 **"UI"** → **"Legacy"** → **"Text"** 선택
   - 이름을 **"ScoreText"**로 변경
   - Inspector에서:
     - **Text**: "Score: 0" 입력
     - **Font Size**: 24
     - **Color**: 흰색
   - **Rect Transform**:
     - **Pos X**: 400, **Pos Y**: 200
     - **Width**: 200, **Height**: 50

3. **줄 수 표시 Text 생성**
   - Canvas 선택 후 **우클릭** → **"UI > Text - TextMeshPro"** 또는 **"UI > Legacy > Text"**
   - 이름을 **"LinesText"**로 변경
   - Inspector에서:
     - **Text**: "Lines: 0" 입력
     - **Font Size**: 24
     - **Color**: 흰색
   - **Rect Transform**:
     - **Pos X**: 400, **Pos Y**: 150
     - **Width**: 200, **Height**: 50

**참고**: 
- UI 연결은 7단계에서 GameController와 함께 설명합니다
- 지금은 행 제거 로직에 집중하세요!

## 💡 이번 단계에서 익히는 개념

- **멤버** = 클래스 안에 들어간 **변수** (저장소).  
  예: GameBoard의 `grid`, TetrisBlock의 `position`, `cells` 는 **멤버**입니다.  
  **메소드**는 이 멤버를 읽거나 바꾸는 함수입니다 (예: `AddToGrid`, `ClearFullRows`).

**📌 복기**: **변수**(멤버) + 그걸 다루는 **메소드**. 한 번에 이해 못했어도 [변수](../참고자료/개념/변수.md) · [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                         | 이번 단계와의 연결                                            |
| ------------------------------------------------- | ------------------------------------------------------------- |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md) | 멤버 = 클래스 안 변수, 메소드 = 그걸 다루는 함수. 한눈에 정리 |
| [반복문](../참고자료/개념/반복문.md)              | for로 행 순회, foreach로 셀 순회. for·foreach 실습            |
| [배열](../참고자료/개념/배열.md)                  | grid[,] 2차원 배열. 2차원 배열 읽고 쓰기 실습                 |
| [충돌 감지](../참고자료/개념/충돌감지.md)         | IsCellEmpty, 범위 확인. CanMoveTo 실습                        |

**📐 이 단계 확장 실습** (전용 씬에서 점진적 연습): [6단계 확장 실습 01 - 그리드와 행 검사](../참고자료/확장-실습/6단계/01-그리드와행검사.md)  
→ 단계별 확장 실습 전체 목차: [단계별 확장 실습 (목차)](../참고자료/확장-실습/README.md)

## ✅ 확인 사항

- [ ] **게임 보드 시각화**: 위 **0. 게임 보드 시각화**(에셋으로 보드 영역 표시)를 적용했는가? — 보드가 보여야 행 제거·블록 쌓임을 확인하기 수월함
- [ ] 한 줄을 채우면 제거되는가?
- [ ] 위 블록들이 아래로 내려오는가?
- [ ] 여러 줄을 동시에 제거할 수 있는가?

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 5단계 - 입력 처리](./5단계-입력-처리.md) | [다음 단계: 7단계 - 점수 및 레벨 시스템 →](./7단계-점수-레벨-시스템.md)
