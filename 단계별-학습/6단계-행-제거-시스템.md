---
layout: default
title: 6단계 - 행 제거 시스템
---

# 6단계: 행 제거 시스템

## 🎯 이 단계에서 배울 것

- 가득 찬 행 감지
- 행 제거 로직
- 위 블록들을 아래로 이동
- 점수 계산

## 📝 실습 내용

### 1. 블록을 보드에 고정하는 함수

먼저 블록이 더 이상 내려갈 수 없을 때 보드에 저장하는 함수를 추가합니다:

`GameBoard.cs`에 추가:

```csharp
// 블록을 그리드에 추가 (고정)
// 참고 블로그 방식: 자식 블록들을 직접 사용
public void AddToGrid(Tetromino tetromino)
{
    // 모든 자식 블록 확인
    for (int i = 0; i < tetromino.transform.childCount; i++)
    {
        Transform child = tetromino.transform.GetChild(i);
        
        // 자식 블록의 Unity 월드 좌표를 정수로 반올림
        int roundX = Mathf.RoundToInt(child.position.x);
        int roundY = Mathf.RoundToInt(child.position.y);
        
        // 보드 범위 확인
        if (roundX >= 0 && roundX < width && roundY >= 0 && roundY < height)
        {
            // 부모를 GameBoard로 변경 (고정된 블록이므로)
            child.SetParent(transform);
            
            // 그리드에 저장
            grid[roundX, roundY] = child;
        }
    }
}
```

**작동 방식**:
1. Tetromino의 모든 자식 블록(Block_0, Block_1 등)을 확인
2. 각 블록의 Unity 월드 좌표를 `Mathf.RoundToInt()`로 정수로 변환
3. 부모를 GameBoard로 변경 (고정된 블록이므로)
4. 그리드 배열에 저장

### 2. Tetromino에 블록 고정 함수 추가

`Tetromino.cs`에 추가:

```csharp
public void LockPiece()
{
    // GameBoard에 블록 추가
    if (gameBoard != null)
    {
        gameBoard.AddToGrid(this);
        
        // 행 제거 확인
        int linesCleared = gameBoard.ClearFullRows();
        
        // 점수 추가 (7단계에서 GameController 연결)
        GameController gameController = FindObjectOfType<GameController>();
        if (gameController != null)
        {
            gameController.AddScore(linesCleared);
        }
        
        // 다음 블록 생성 (8단계에서 Spawner 연결)
        Spawner spawner = FindObjectOfType<Spawner>();
        if (spawner != null)
        {
            spawner.SpawnNext();
        }
    }
    
    // 현재 Tetromino 부모 오브젝트 삭제 (자식은 이미 GameBoard로 이동됨)
    Destroy(gameObject);
}
```

### 3. MoveDown 함수 수정

4단계에서 만든 `MoveDown()` 함수를 수정합니다:

```csharp
public void MoveDown()
{
    if (ValidMove(Vector3.down))
    {
        transform.position += Vector3.down;
    }
    else
    {
        // 더 이상 내려갈 수 없으면 블록 고정
        LockPiece();
    }
}
```

### 4. 행 제거 함수 구현

`GameBoard.cs`에 추가:

```csharp
public void ClearFullRows()
{
    for (int y = 0; y < height; y++)
    {
        if (IsRowFull(y))
        {
            ClearRow(y);
            MoveRowsDown(y);
            y--;  // 다시 확인
        }
    }
}

bool IsRowFull(int row)
{
    for (int x = 0; x < width; x++)
    {
        if (grid[x, row] == null)
            return false;
    }
    return true;
}

void ClearRow(int row)
{
    for (int x = 0; x < width; x++)
    {
        if (grid[x, row] != null)
        {
            Destroy(grid[x, row].gameObject);
            grid[x, row] = null;
        }
    }
}

void MoveRowsDown(int clearedRow)
{
    // 위의 행들을 아래로 이동
    for (int y = clearedRow + 1; y < height; y++)
    {
        for (int x = 0; x < width; x++)
        {
            if (grid[x, y] != null)
            {
                // 한 칸 아래로 이동
                grid[x, y - 1] = grid[x, y];
                grid[x, y] = null;
                
                // 시각적 위치도 업데이트
                grid[x, y - 1].position += Vector3.down;
            }
        }
    }
}

// 제거한 행 개수를 반환하도록 수정
public int ClearFullRows()
{
    int linesCleared = 0;
    
    for (int y = 0; y < height; y++)
    {
        if (IsRowFull(y))
        {
            ClearRow(y);
            MoveRowsDown(y);
            y--;  // 다시 확인 (한 칸 아래로 내려왔으므로)
            linesCleared++;
        }
    }
    
    return linesCleared;
}
```

## 🔗 이전 단계와의 연결

이 단계에서는:
- **3단계의 프리팹**: 자식 블록들을 직접 사용 (`transform.GetChild()`)
- **4단계의 `MoveDown()`**: 블록이 더 이상 내려갈 수 없을 때 `LockPiece()` 호출
- **2단계의 `GameBoard`**: 그리드에 블록 저장 및 행 제거
- **7단계의 `GameController`**: 행 제거 개수를 받아서 점수 계산

**작동 흐름**:
1. 블록이 바닥에 닿음 → `MoveDown()`에서 `LockPiece()` 호출
2. `LockPiece()` → `gameBoard.AddToGrid()`로 자식 블록들을 그리드에 저장
3. `gameBoard.ClearFullRows()` → 가득 찬 행 제거
4. 제거한 행 개수 반환 → GameController에서 점수로 변환

**참고 블로그 방식의 특징**:
- 자식 블록을 `transform.GetChild()`로 직접 접근
- Unity 좌표를 `Mathf.RoundToInt()`로 정수로 변환
- 부모를 GameBoard로 변경하여 고정

## 📺 UI 준비하기 (7단계에서 자세히 설명)

행을 제거하면 점수가 올라갑니다. 점수를 화면에 표시하려면 UI가 필요합니다.

**7단계에서 UI를 만들 예정이지만, 미리 만들어두고 싶다면:**

1. **Canvas 생성** (아직 없다면)
   - Hierarchy 창의 빈 공간에서 **우클릭**
   - **"UI"** → **"Canvas"** 선택

2. **점수 표시 Text 생성**
   - Hierarchy에서 **"Canvas"** 클릭
   - Canvas 선택 상태에서 Hierarchy 창에서 **우클릭**
   - **"UI"** → **"Text - TextMeshPro"** 또는 **"UI"** → **"Legacy"** → **"Text"** 선택
   - 이름을 **"ScoreText"**로 변경
   - Inspector에서:
     - **Text**: "Score: 0" 입력
     - **Font Size**: 24
     - **Color**: 흰색
   - **Rect Transform**:
     - **Pos X**: 400, **Pos Y**: 200
     - **Width**: 200, **Height**: 50

3. **줄 수 표시 Text 생성**
   - Canvas 선택 후 **우클릭** → **"UI > Text - TextMeshPro"** 또는 **"UI > Legacy > Text"**
   - 이름을 **"LinesText"**로 변경
   - Inspector에서:
     - **Text**: "Lines: 0" 입력
     - **Font Size**: 24
     - **Color**: 흰색
   - **Rect Transform**:
     - **Pos X**: 400, **Pos Y**: 150
     - **Width**: 200, **Height**: 50

**참고**: 
- UI 연결은 7단계에서 GameController와 함께 설명합니다
- 지금은 행 제거 로직에 집중하세요!

## ✅ 확인 사항

- [ ] 한 줄을 채우면 제거되는가?
- [ ] 위 블록들이 아래로 내려오는가?
- [ ] 여러 줄을 동시에 제거할 수 있는가?

---

[← 이전 단계: 5단계 - 입력 처리](./5단계-입력-처리.md) | [다음 단계: 7단계 - 점수 및 레벨 시스템 →](./7단계-점수-레벨-시스템.md)
