---
layout: default
title: 6단계 - 행 제거 시스템
---

# 6단계: 행 제거 시스템

## 🎯 이 단계에서 배울 것

- **게임 보드 시각화** (보드 영역을 화면에 표시 — 블록이 쌓이고 행이 지워지는 모습을 보기 위해)
- 가득 찬 행 감지
- 행 제거 로직
- 위 블록들을 아래로 이동
- 점수 계산

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                                         | 설명                                                                                                                                    |
| ----------------------- | -------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **내가 만드는 것**      | **GameBoard.AddToGrid**, **ClearFullRows**, **TetrisBlock.LockPiece**                  | 우리가 정의하는 "블록을 어디에 고정할지", "가득 찬 행을 어떻게 지우고 위 블록을 내릴지". **테트리스 규칙** 전부 우리 로직.              |
| **엔진(API)이 주는 것** | **Transform**, **SetParent**, **GetChild**, **Mathf.RoundToInt**, **FindObjectOfType** | Unity가 제공. **부모 바꾸기(SetParent)**, **자식 접근(GetChild)** 는 엔진 기능. 우리는 "**언제** 고정하고 **어느 칸**에 넣을지"만 정함. |

**왜 엔진 것을 쓰나?**  
오브젝트의 부모를 바꾸고, 자식 순서를 읽는 건 **엔진(Transform)** 이 하는 일입니다. 우리는 **그리드(grid)** 에 "어느 칸에 뭐가 있는지"를 우리 방식으로 저장하고, **언제 행을 지우고, 어떻게 점수를 넘길지**만 만듭니다. **FindObjectOfType**으로 GameController를 찾는 것도 "씬에 있는 걸 엔진이 찾아 주는 API"를 쓰는 것입니다.

---

## 📝 실습 내용

**💡 한 번에 다 하지 않아도 됩니다.**  
6단계는 블록 고정 + 행 제거까지 있어서 분량이 조금 많습니다. **게임 보드 시각화** → **AddToGrid** → **LockPiece** → **행 제거** 순서로 끊어서 해도 됩니다. 1시간 넘게 붙들고 있으면 피로해지니까, 구간마다 Play 눌러 보고 "블록이 쌓인다 → 행이 지워진다"만 확인해도 충분합니다.

---

**📌 발음**: Hierarchy, Sprite Renderer 등 영어 표기 읽는 법 → **[영어 용어 발음·표기](../참고자료/영어-용어-발음-표기.md)** (한글 발음만 보셔도 됩니다)

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**

### 0. 6단계 시작 전 점검 (입력시스템 포함)

행 제거·블록 고정을 제대로 보려면 **5단계까지** 아래가 동작해야 합니다. 하나라도 안 되면 6단계에서 "블록이 안 움직인다"고 느낄 수 있습니다.

| 확인 항목                  | 확인 방법                                                                                                                                                                               |
| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **입력시스템 (5단계)**     | **Play** 누른 뒤 **화살표 키 또는 WASD**로 스폰된 블록이 **좌우·회전·아래**로 움직이는지 확인. 안 되면 → [5단계 - 시작 전 점검·키 눌러도 안 될 때](./5단계-입력-처리.md) 순서대로 점검. |
| **GameBoard·Spawner·블록** | 5단계 시작 전 점검과 동일. GameBoard, Spawner, 블록 프리팹(루트에 TetrisBlock)이 씬에 있고 연결돼 있는지.                                                                               |

위가 맞으면 **0. 게임 보드 시각화**로 넘어가면 됩니다. (보드가 안 보여도 행 제거 코드는 동작하지만, 보이면 훨씬 덜 지루합니다.)

**맨 아래 줄이 반쯤 잘려 보이면** (바닥이 0이 아닌 것처럼 보일 때) → [4단계 - 바닥(보드 아래)이 좌표와 안 맞아 보일 때](./4단계-블록-이동-구현.md#1-2-바닥보드-아래이-좌표와-안-맞아-보일-때) 참고. 카메라 **Size를 10.5**로 키우면 됩니다.

**📐 이번 단계 예시 구조 (가이드)**  
행 제거는 **GameBoard**에 AddToGrid, ClearFullRows 등을 추가하고, **TetrisBlock**의 LockPiece에서 GameBoard·GameController·Spawner를 호출하는 구조입니다. 보드 시각화를 쓰면 Hierarchy는 아래처럼 됩니다. **이 예시로 Hierarchy(위치)를 체크**해 보세요.

```
씬 (Tetris)
├─ Main Camera
├─ GameBoard
│  └─ BoardBackground   ← (선택) Sprite Renderer + Square. 보드 영역 표시
├─ Spawner
│  └─ (Spawn Point 등)
├─ InputHandler        ← 루트 레벨
└─ (기타)
```

**코드 연결**: LockPiece → AddToGrid, ClearFullRows, AddScore, SpawnNext. **전체 구조** → [시스템 설계 개요](../참고자료/시스템설계개요.md)

---

### 0. 게임 보드 시각화 (권장) {#game-board-visualization}

GameBoard는 빈 오브젝트라 화면에 안 보입니다. **여기**에서는 스프라이트 1개로 보드 배경만 넣어 둡니다. 코드 수정 없이 에디터에서만 설정하면 됩니다.

#### 에셋으로 보드 영역 표시 (스프라이트 1개)

1. **스프라이트 에셋 만들기**  
   - **[Project > Assets]** (또는 **Create > Folder**로 `Sprites` 폴더 만든 뒤 **[Project > Assets > Sprites]**) 선택  
   - **우클릭** → **Create** → **2D** → **Sprites** → **Square**  
   - 생성된 **Square** 위치: **[Project > Assets > Square]** (또는 Sprites 폴더 안). 보드 배경용 스프라이트입니다.

2. **보드 배경 오브젝트 만들기**  
   - **[Hierarchy > GameBoard]** 클릭 → **우클릭** → **Create Empty**  
   - 이름: **BoardBackground** → Hierarchy 트리: **[Hierarchy > GameBoard > BoardBackground]**

3. **Sprite Renderer**(읽는 법: 스프라이트 렌더러) 추가  
   - **[Hierarchy > GameBoard > BoardBackground]** 선택  
   - **[Inspector > Add Component]** 클릭 → **Sprite Renderer** 검색 후 추가

4. **스프라이트**(Sprite, 읽는 법: 스프라이트) 연결  
   - **[Inspector > BoardBackground > Sprite Renderer > Sprite]** (맨 위 "None" 칸) 클릭  
   - **[Project > Assets > Square]** (또는 Sprites > Square)를 선택해 넣거나, Square를 Sprite 칸으로 드래그

5. **Transform 설정** (GameBoard가 Position (0, 0, 0)일 때 기준)  
   - **[Inspector > BoardBackground > Transform]**  
   - **Position**: **(5, 10, 0)** — 10×20 보드의 가로 중앙(5), 세로 중간(10)  
   - **Rotation**: **(0, 0, 0)**  
   - **Scale**: **(10, 20, 1)** — 보드 전체를 한 번에 덮는 크기

6. **색상·정렬** (선택)  
   - **[Inspector > BoardBackground > Sprite Renderer > Color]** 를 **어두운 회색** 등으로 변경  
   - **Sorting Layer**(읽는 법: 소팅 레이어) / **Order in Layer**(읽는 법: 오더 인 레이어)를 블록보다 **작은 값**으로 두면 배경이 블록 뒤에 그려집니다.

**정리**: 에셋(Square 스프라이트) 1개 + BoardBackground 오브젝트 + Sprite Renderer 설정만으로 보드 영역이 Game 뷰에 보입니다. 스크립트 수정은 필요 없습니다.

---

**📷 카메라 위치·조정** (고정된 이유, 에디터에서 수정이 안 될 때) → [카메라 설정 가이드](../참고자료/카메라-설정-가이드.md)

---


### 1. 블록을 보드에 고정하는 함수

먼저 블록이 더 이상 내려갈 수 없을 때 보드에 저장하는 함수를 추가합니다.

**📌 코드 읽기 전에: 멤버·메소드·상속 구분**  
소스코드에서 **내가 만든 것**과 **Unity에서 오는 것**을 구분하기 위해 주석을 달아 둡니다. (자세한 표기 설명 → [4단계 - 소스코드 구분 표기](./4단계-블록-이동-구현.md))

- **[우리 멤버]** / **[우리 변수]** = 우리가 선언한 필드. 예: `width`, `height`, `grid`, `gameBoard`
- **[우리 메소드]** / **[우리 구현]** = 우리가 만든 함수. 예: `AddToGrid()`, `ClearFullRows()`, `LockPiece()`
- **[Unity가 호출]** = `Start()`, `Update()`, `Awake()` — **이름을 맞추면** 엔진이 **알아서** 부르는 **상속받은 메소드**
- **[MonoBehaviour 상속]** = `class 이름 : MonoBehaviour` — Unity 부모 클래스를 상속. 그래서 `transform`, `gameObject`, `Start()` 등을 쓸 수 있음
- **[Unity 프로퍼티]** = 괄호 없이 쓰는 값. Unity가 제공. 예: `transform`, `position`, `gameObject`, `.text`
- **[Unity API]** = Unity가 제공하는 함수. 우리는 호출만. 예: `FindObjectOfType()`, `GetChild()`, `Destroy()`

---

`GameBoard.cs`에 추가:

```csharp
public void AddToGrid(TetrisBlock block)   // [우리 메소드] 블록을 그리드에 추가 (고정)
{
    for (int i = 0; i < block.transform.childCount; i++)   // block.transform, childCount: [Unity 프로퍼티] 상속
    {
        Transform child = block.transform.GetChild(i);   // GetChild(i): [Unity API]
        int roundX = Mathf.RoundToInt(child.position.x);   // position: [Unity 프로퍼티], Mathf.RoundToInt: [Unity API]
        int roundY = Mathf.RoundToInt(child.position.y);
        if (roundX >= 0 && roundX < width && roundY >= 0 && roundY < height)   // width, height: [우리 멤버]
        {
            child.SetParent(transform);   // SetParent: [Unity API], transform: [Unity 프로퍼티] (이 GameBoard의 Transform)
            grid[roundX, roundY] = child;   // grid: [우리 멤버]
        }
    }
}
```

**작동 방식**:
1. TetrisBlock의 모든 자식 블록(Block_0, Block_1 등)을 확인
2. 각 블록의 Unity 월드 좌표를 `Mathf.RoundToInt()`로 정수로 변환
3. 부모를 GameBoard로 변경 (고정된 블록이므로)
4. 그리드 배열에 저장

**📌 복기**: **배열** = grid[,]에 칸을 순서대로 저장. [배열](../참고자료/개념/배열.md)에서 다시 실습해 보세요.

**💡 여기까지 했으면** Play 눌러서 블록을 바닥까지 내려보세요. 블록이 **고정**되면 AddToGrid가 동작한 겁니다. (아직 다음 블록은 안 나와도 괜찮습니다. 8단계에서 이어집니다.)

**📌 코드 연결**  
위 LockPiece() 안에는 **GameController.AddScore(linesCleared)** 와 **Spawner.SpawnNext()** 호출이 **같이** 들어 있어야 합니다. 7단계에서 점수가 올라가고, 8단계에서 다음 블록이 나오려면 이 연결이 필수입니다. 아래 "2. TetrisBlock에 블록 고정 함수 추가"의 **전체 LockPiece 코드**를 그대로 쓰면 됩니다.

---

### 2. TetrisBlock에 블록 고정 함수 추가

`TetrisBlock.cs`에 추가:

```csharp
public void LockPiece()   // [우리 메소드] 블록 고정 시 호출
{
    if (gameBoard != null)   // gameBoard: [우리 멤버]
    {
        gameBoard.AddToGrid(this);   // AddToGrid: [우리 메소드] GameBoard 쪽, this: 우리 TetrisBlock 인스턴스
        int linesCleared = gameBoard.ClearFullRows();   // ClearFullRows: [우리 메소드] GameBoard 쪽

        GameController gameController = FindObjectOfType<GameController>();   // [Unity API]
        if (gameController != null)
        {
            gameController.AddScore(linesCleared);   // AddScore: [우리 메소드] GameController 쪽
        }

        Spawner spawner = FindObjectOfType<Spawner>();   // [Unity API]
        if (spawner != null)
        {
            spawner.SpawnNext();   // SpawnNext: [우리 메소드] Spawner 쪽
        }
    }
    Destroy(gameObject);   // Destroy: [Unity API], gameObject: [Unity 프로퍼티] 상속 — 이 스크립트가 붙은 오브젝트
}
```

### 3. MoveDown 함수 수정

4단계에서 만든 `MoveDown()` 함수를 수정합니다:

```csharp
public void MoveDown()   // [우리 메소드]
{
    if (ValidMove(Vector3.down))   // ValidMove: [우리 메소드], Vector3.down: [Unity 프로퍼티]
    {
        transform.position += Vector3.down;   // transform, position: [Unity 프로퍼티] 상속
    }
    else
    {
        LockPiece();   // [우리 메소드]
    }
}
```

### 4. 행 제거 함수 구현

#### 행 제거 개념 (코드 전에 이해하기)

**행 제거**란 **가로 한 줄이 블록으로 꽉 찼을 때**, 그 줄을 없애고 **그 위에 있던 블록들을 한 칸씩 아래로 내리는** 동작입니다. 테트리스의 핵심 규칙 중 하나입니다.

**동작 순서 (개념)**  
1. **가득 찬 행 찾기** — 보드에서 “가로 한 줄이 전부 블록인지” 확인합니다.  
2. **그 행 지우기** — 해당 줄의 블록을 없애고, 그리드에서도 비웁니다.  
3. **위 블록들 내리기** — 지운 줄 **위쪽**에 있던 모든 블록을 **한 칸씩 아래**로 옮깁니다. (화면에서도 한 칸씩 내려가야 하므로 `position += Vector3.down`로 옮깁니다.)

**아래에서 위로 확인하는 이유**  
- y=0(맨 아래)부터 y=19(맨 위)까지 순서대로 검사합니다.  
- 한 행을 지우고 위 행들을 내리면, **그 자리(y)에 새로 내려온 행**이 채워집니다. 그래서 **같은 y를 한 번 더 검사**해야 합니다. `y--`는 “한 칸 아래로 내려왔으니 같은 y를 다시 보자”는 뜻입니다.

**예시 (개념)**  
- 지우기 전: 5번째 행(y=5)이 가득 참. 그 위 6, 7, 8… 행에는 블록이 있음.  
- 5번째 행 지우기 → 6번째 행이 5번째 자리로, 7번째 행이 6번째 자리로… 한 칸씩 내려옴.  
- 그 다음에도 “지금 5번째 행이 가득 찬가?”를 다시 확인해야 하므로, for문에서 `y--`로 같은 y를 다시 검사합니다.

**코드와의 대응**  
- `IsRowFull(y)` = “y번째 행이 가득 찬가?”  
- `ClearRow(y)` = “y번째 행의 블록 지우기”  
- `MoveRowsDown(y)` = “y 위쪽 행들을 한 칸씩 아래로 이동”

---

**📌 "한 행이 가득 찼는지"만 먼저 연습하고 싶다면** → [6단계 확장 실습 01 - 그리드와 행 검사](../참고자료/확장-실습/6단계/01-그리드와행검사.md).

**💡 행 제거 코드가 길어 보여도** IsRowFull → ClearRow → MoveRowsDown → ClearFullRows 순서만 잡으면 됩니다. "한 줄 다 채우면 지우고, 위에 걸 내린다"가 전부라서, 코드가 그걸 반복할 뿐입니다.

---

`GameBoard.cs`에 추가:

```csharp
bool IsRowFull(int row)   // [우리 메소드]
{
    for (int x = 0; x < width; x++)   // width: [우리 멤버]
    {
        if (grid[x, row] == null)   // grid: [우리 멤버]
        {
            return false;
        }
    }
    return true;
}

void ClearRow(int row)   // [우리 메소드]
{
    for (int x = 0; x < width; x++)
    {
        if (grid[x, row] != null)
        {
            Destroy(grid[x, row].gameObject);   // Destroy: [Unity API], gameObject: [Unity 프로퍼티] 상속
            grid[x, row] = null;
        }
    }
}

void MoveRowsDown(int clearedRow)   // [우리 메소드]
{
    for (int y = clearedRow + 1; y < height; y++)   // height: [우리 멤버]
    {
        for (int x = 0; x < width; x++)   // width: [우리 멤버]
        {
            if (grid[x, y] != null)   // grid: [우리 멤버]
            {
                grid[x, y - 1] = grid[x, y];
                grid[x, y] = null;
                grid[x, y - 1].position += Vector3.down;   // position: [Unity 프로퍼티], Vector3.down: [Unity 프로퍼티]
            }
        }
    }
}

public int ClearFullRows()   // [우리 메소드] 가득 찬 행 지우고 위 블록 내리기, 제거한 행 개수 반환
{
    int linesCleared = 0;
    for (int y = 0; y < height; y++)   // height: [우리 멤버]
    {
        if (IsRowFull(y))   // IsRowFull: [우리 메소드]
        {
            ClearRow(y);   // [우리 메소드]
            MoveRowsDown(y);   // [우리 메소드]
            y--;
            linesCleared++;
        }
    }
    return linesCleared;
}
```

## 🔗 이전 단계와의 연결

**이 섹션은 실습이 아닙니다.** 따로 할 일이나 체크할 항목은 없습니다. "이 단계가 이전 단계와 어떻게 이어지는지"만 **참고**로 정리한 것이므로, 궁금할 때만 읽으면 됩니다.

이 단계에서는:
- **3단계의 프리팹**: 자식 블록들을 직접 사용 (`transform.GetChild()`)
- **4단계의 `MoveDown()`**: 블록이 더 이상 내려갈 수 없을 때 `LockPiece()` 호출
- **2단계의 `GameBoard`**: 그리드에 블록 저장 및 행 제거
- **7단계의 `GameController`**: 행 제거 개수를 받아서 점수 계산

**작동 흐름**:
1. 블록이 바닥에 닿음 → `MoveDown()`에서 `LockPiece()` 호출
2. `LockPiece()` → `gameBoard.AddToGrid()`로 자식 블록들을 그리드에 저장
3. `gameBoard.ClearFullRows()` → 가득 찬 행 제거
4. 제거한 행 개수 반환 → GameController에서 점수로 변환

**참고 블로그 방식의 특징**:
- 자식 블록을 `transform.GetChild()`로 직접 접근
- Unity 좌표를 `Mathf.RoundToInt()`로 정수로 변환
- 부모를 GameBoard로 변경하여 고정

## 📺 UI 준비하기 (7단계에서 자세히 설명)

행을 제거하면 점수가 올라갑니다. 점수를 화면에 표시하려면 UI가 필요합니다.

**7단계에서 UI를 만들 예정이지만, 미리 만들어두고 싶다면:** (위치 표기: [1단계 - 위치 표기 규칙](./1단계-Unity-기초.md#location-tree-notation))

1. **Canvas 생성** (아직 없다면)
   - **[Hierarchy]** 빈 공간 **우클릭** → **"UI"** → **"Canvas"**  
   - 결과: **[Hierarchy > Canvas]**

2. **점수 표시 Text 생성**
   - **[Hierarchy > Canvas]** 클릭 → 선택 상태에서 **Hierarchy 빈 공간** **우클릭**  
   - **"UI"** → **"Text - TextMeshPro"** 또는 **"Legacy"** → **"Text"**  
   - 이름 **"ScoreText"** 로 변경 → **[Hierarchy > Canvas > ScoreText]**  
   - **[Inspector > ScoreText > Text (TMP)** 또는 **Text**]: **Text** "Score: 0", **Font Size** 24, **Color** 흰색  
   - **[Inspector > ScoreText > Rect Transform]**: **Pos X** 400, **Pos Y** 200, **Width** 200, **Height** 50

3. **줄 수 표시 Text 생성**
   - **[Hierarchy > Canvas]** 선택 후 **우클릭** → **"UI > Text - TextMeshPro"** 또는 **"Legacy > Text"**  
   - 이름 **"LinesText"** 로 변경 → **[Hierarchy > Canvas > LinesText]**  
   - **[Inspector > LinesText > Text]** "Lines: 0", **Font Size** 24, **Color** 흰색  
   - **[Inspector > LinesText > Rect Transform]**: Pos X 400, Pos Y 150, Width 200, Height 50

**참고**: 
- UI 연결은 7단계에서 GameController와 함께 설명합니다
- 지금은 행 제거 로직에 집중하세요!

## 💡 이번 단계에서 익히는 개념

- **멤버** = 클래스 안에 들어간 **변수** (저장소).  
  예: GameBoard의 `grid`, TetrisBlock의 `position`, `cells` 는 **멤버**입니다.  
  **메소드**는 이 멤버를 읽거나 바꾸는 함수입니다 (예: `AddToGrid`, `ClearFullRows`).

- **프로퍼티** = **변수처럼** 쓰지만, 읽기/쓰기 시 로직이 들어갈 수 있는 멤버.  
  `transform`, `position`, `childCount`, `gameObject` 처럼 **괄호 () 없이** 쓰는 것은 대부분 **Unity 프로퍼티**입니다. "겉으로는 변수처럼 보이는데, Unity가 내부적으로 처리해 준다"고 생각하면 됩니다.

**📌 복기**: **변수**(멤버) + 그걸 다루는 **메소드**. 한 번에 이해 못했어도 [변수](../참고자료/개념/변수.md) · [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                         | 이번 단계와의 연결                                            |
| ------------------------------------------------- | ------------------------------------------------------------- |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md) | 멤버 = 클래스 안 변수, 메소드 = 그걸 다루는 함수. 한눈에 정리 |
| [반복문](../참고자료/개념/반복문.md)              | for로 행 순회, foreach로 셀 순회. for·foreach 실습            |
| [배열](../참고자료/개념/배열.md)                  | grid[,] 2차원 배열. 2차원 배열 읽고 쓰기 실습                 |
| [충돌 감지](../참고자료/개념/충돌감지.md)         | IsCellEmpty, 범위 확인. CanMoveTo 실습                        |

**📐 이 단계 확장 실습** (전용 씬에서 점진적 연습): [6단계 확장 실습 01 - 그리드와 행 검사](../참고자료/확장-실습/6단계/01-그리드와행검사.md)  
→ 단계별 확장 실습 전체 목차: [단계별 확장 실습 (목차)](../참고자료/확장-실습/README.md)

## ✅ 확인 사항

- [ ] **게임 보드 시각화**: 위 **0. 게임 보드 시각화**(에셋으로 보드 영역 표시)를 적용했는가? — 보드가 보여야 행 제거·블록 쌓임을 확인하기 수월함. (맨 아래 줄이 반쯤 잘려 보이면 → [4단계 - 바닥이 좌표와 안 맞아 보일 때](./4단계-블록-이동-구현.md#1-2-바닥보드-아래이-좌표와-안-맞아-보일-때) 참고.)
- [ ] 한 줄을 채우면 제거되는가?
- [ ] 위 블록들이 아래로 내려오는가?
- [ ] 여러 줄을 동시에 제거할 수 있는가?

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 5단계 - 입력 처리](./5단계-입력-처리.md) | [다음 단계: 7단계 - 점수 및 레벨 시스템 →](./7단계-점수-레벨-시스템.md)
