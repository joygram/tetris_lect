---
layout: default
title: 4단계 - 블록 이동 구현
---

# 4단계: 블록 이동 구현

## 🎯 이 단계에서 배울 것

- 블록의 좌우 이동
- 자동 낙하 구현
- 회전 기능 구현
- 충돌 감지

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                                                                         | 설명                                                                                                              |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **내가 만드는 것**      | **TetrisBlock**의 **MoveLeft/MoveRight/MoveDown/Rotate**, **ValidMove**                                                | 우리가 정의하는 "이동·회전 규칙"과 "이동 가능한지" 판단. **테트리스 규칙**은 전부 우리 로직.                      |
| **엔진(API)이 주는 것** | **MonoBehaviour**, **Start()/Update()**, **FindObjectOfType**, **Transform**, **Time.deltaTime**, **Mathf.RoundToInt** | Unity가 제공. **Update()**는 엔진이 "매 프레임" 불러 주는 **자리**, **Time.deltaTime**은 엔진이 주는 "경과 시간". |

**왜 엔진 것을 쓰나?**  
게임이 매 프레임 돌아가려면 **Update()** 같은 **엔진이 정해 둔 자리**에 우리 코드를 넣어야 합니다. **Time.deltaTime**은 "프레임 간 시간"을 엔진이 알려 주므로, 우리는 **그걸 이용해 "1초에 한 칸"** 같은 규칙만 짜면 됩니다. 이동·회전 **로직**은 우리가 만들고, **위치 읽기/쓰기**는 엔진 타입(Transform)을 씁니다.

---

## 📝 실습 내용

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**

### 1. GameBoard 연결 및 기본 구조

`Assets/Scripts/TetrisBlock.cs`를 다음과 같이 작성합니다:

```csharp
using UnityEngine;

public class TetrisBlock : MonoBehaviour
{
    private GameBoard gameBoard;
    public float fallSpeed = 1f;  // 낙하 속도 (초)
    private float fallTimer = 0f;
    
    void Start()
    {
        // GameBoard 찾기
        gameBoard = FindObjectOfType<GameBoard>();
        
        // 초기 위치는 Spawner에서 설정하거나 여기서 설정
        // transform.position은 Unity 씬에서 설정된 Spawner 위치 사용
    }
    
    void Update()
    {
        // 자동 낙하
        fallTimer += Time.deltaTime;
        if (fallTimer >= fallSpeed)
        {
            MoveDown();
            fallTimer = 0f;
        }
    }
}
```

### 2. 이동 가능한지 확인하는 함수

**참고 블로그 방식**: 자식 블록들의 위치를 직접 확인합니다.

```csharp
// 이동 가능한지 확인하는 함수
bool ValidMove(Vector3 offset)
{
    // 모든 자식 블록 확인
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);
        
        // 이동 후 위치 계산
        Vector3 newPos = child.position + offset;
        
        // Unity 좌표를 정수로 반올림 (게임 보드 그리드에 맞추기)
        int roundX = Mathf.RoundToInt(newPos.x);
        int roundY = Mathf.RoundToInt(newPos.y);
        
        // 보드 범위 확인
        // 왜 ||(또는)인가? "범위 밖" = "x가 너무 작거나 OR 너무 크거나 OR y가 너무 작거나 OR 너무 크다"
        // → 하나라도 해당되면 범위 밖이므로 || 사용. (범위 "안"이면 && 사용 → 아래 연산자 설명 참고)
        if (roundX < 0 || roundX >= gameBoard.width || 
            roundY < 0 || roundY >= gameBoard.height)
        {
            return false;  // 범위 밖!
        }
        
        // 이미 블록이 있는지 확인 (6단계에서 구현)
        // if (!gameBoard.IsCellEmpty(roundX, roundY))
        //     return false;
    }
    
    return true;  // 이동 가능!
}
```

**Mathf.RoundToInt() 설명**:
- 소수점을 반올림하여 정수로 만듭니다
- 예: 5.2 → 5, 5.7 → 6, 10.8 → 11
- Unity 좌표가 소수점일 수 있으므로 정수로 변환하여 그리드에 맞춥니다

### 📌 연산자 설명: += , && , || (이번 단계에서 자주 쓰는 것)

이번 단계 코드에서 **+=** , **&&** , **||** 가 나옵니다. 의미를 알아두면 읽기 편합니다.

#### += 연산자 (복합 대입) — 쉽게 이해하기

**쉽게 말하면**: **저장소(변수)에 있는 값에, 조금을 더해서, 그 결과를 다시 그 저장소에 넣는 것**입니다.

**두 가지 쓰는 법 (똑같은 뜻)**  
- `fallTimer = fallTimer + Time.deltaTime;`  ← "지금 fallTimer에 Time.deltaTime을 더한 값을, fallTimer에 넣는다"  
- `fallTimer += Time.deltaTime;`  ← 위와 **완전히 같은 뜻**인데, 짧게 쓴 것입니다.

즉, **+=** 는 "더한 다음에, 그 결과를 다시 그 변수에 넣는다"를 **한 번에** 쓰는 기호라고 보면 됩니다.

**숫자로 보기 (자동 낙하)**  
- 처음: `fallTimer` = 0  
- 1프레임 후: `fallTimer += 0.016` → fallTimer = 0 + 0.016 = **0.016**  
- 2프레임 후: `fallTimer += 0.016` → fallTimer = 0.016 + 0.016 = **0.032**  
- … 이렇게 **조금씩 더해져서** 1초(예: 1.0)가 되면 MoveDown()을 부르고, fallTimer를 0으로 돌립니다.

**이동할 때**  
- `transform.position += Vector3.left;`  
  → "**지금 위치**" + "**왼쪽 한 칸**" = **새 위치** → 그 새 위치를 다시 position에 넣기 → 블록이 왼쪽으로 한 칸 이동한 것처럼 보입니다.

**헷갈리면**: "**더하기**를 한 다음, 그 **결과를 다시 그 변수(저장소)에 넣는 것**"이라고만 생각해도 됩니다. `a += b` = "a에 b를 더해서, 다시 a에 넣기."

#### && (그리고) 와 || (또는) — 쉽게 이해하기

**|| (또는) — 쉽게 말하면**  
- **"둘 중 하나라도 맞으면 된다"** 라고 생각하면 됩니다.  
  예: "오늘 **비 오거나** 눈 오면 우산 챙긴다" → 비 오기 **또는** 눈 오기 **하나라도** 해당되면 우산 챙김.  
- 코드에서는: `A || B` → **A가 참이거나 B가 참이면** 결과가 true. **둘 다 거짓일 때만** false.

**&& (그리고) — 쉽게 말하면**  
- **"둘 다 맞아야 한다"** 라고 생각하면 됩니다.  
  예: "x가 0 이상 **이고** 10 미만이다" → **둘 다** 만족해야 true.

**ValidMove에서는 "범위 밖인가?"를 묻습니다.**  
- 범위 **밖** = "x가 너무 작다 **또는** x가 너무 크다 **또는** y가 너무 작다 **또는** y가 너무 크다"  
  → **이 중 하나라도** 해당되면 "범위 밖"이에요. 그래서 **|| (또는)** 를 씁니다.  
- 읽는 법:  
  `roundX < 0 || roundX >= width || ...`  
  = "x가 0 미만 **이거나**, x가 width 이상 **이거나**, … **하나라도** 참이면" → 범위 밖 → false(이동 불가).

**반대로 "범위 안"이면**  
- "x가 0 이상 **이고** width 미만 **이고** y가 0 이상 **이고** height 미만" → **모두** 만족해야 하므로 **&&** 를 씁니다.

**정리**  
| 묻는 말          | 쉽게 말하면          | 연산자          |
| ---------------- | -------------------- | --------------- |
| 범위 **밖**인가? | 하나라도 해당되면 밖 | **\|\|** (또는) |
| 범위 **안**인가? | 모두 만족해야 안     | **&&** (그리고) |

**헷갈리면**: **||** = "**또는**" = **하나라도 맞으면** 된다. **&&** = "**그리고**" = **다 맞아야** 된다.

### 3. 이동 함수 구현

```csharp
public void MoveLeft()
{
    if (ValidMove(Vector3.left))  // 왼쪽으로 1칸
    {
        transform.position += Vector3.left;
    }
}

public void MoveRight()
{
    if (ValidMove(Vector3.right))  // 오른쪽으로 1칸
    {
        transform.position += Vector3.right;
    }
}

public void MoveDown()
{
    if (ValidMove(Vector3.down))  // 아래로 1칸
    {
        transform.position += Vector3.down;
    }
    else
    {
        // 더 이상 내려갈 수 없으면 블록 고정 (6단계에서 구현)
        // LockPiece();
    }
}
```

**작동 방식**:
1. `ValidMove()`로 이동 가능한지 확인
2. 가능하면 `transform.position`을 직접 변경
3. 부모가 이동하면 자식 블록들도 함께 이동 (Unity의 Transform 시스템)

### 4. 회전 기능 구현

**참고 블로그 방식**: 각 자식 블록의 Local Position을 회전시킵니다.

```csharp
public void Rotate()
{
    // 회전 후 위치들을 저장할 배열 (자식 개수만큼)
    Vector3[] newLocalPositions = new Vector3[transform.childCount];
    
    // 각 자식 블록의 Local Position을 90도 회전
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);
        Vector3 localPos = child.localPosition;
        
        // 90도 시계 방향 회전 공식: (x, y) → (-y, x)
        float newX = -localPos.y;
        float newY = localPos.x;
        newLocalPositions[i] = new Vector3(newX, newY, 0);
    }
    
    // 회전 후 위치가 유효한지 확인
    bool canRotate = true;
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);
        Vector3 newWorldPos = transform.position + newLocalPositions[i];
        
        // Unity 좌표를 정수로 반올림
        int roundX = Mathf.RoundToInt(newWorldPos.x);
        int roundY = Mathf.RoundToInt(newWorldPos.y);
        
        // 보드 범위 확인
        if (roundX < 0 || roundX >= gameBoard.width || 
            roundY < 0 || roundY >= gameBoard.height)
        {
            canRotate = false;
            break;
        }
    }
    
    // 회전 가능하면 적용
    if (canRotate)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform child = transform.GetChild(i);
            child.localPosition = newLocalPositions[i];
        }
    }
}
```

**📌 복기**: `newLocalPositions` 는 **배열**(같은 타입을 순서대로 저장). 한 번에 이해 못했어도 [배열](../참고자료/개념/배열.md)에서 다시 실습해 보세요.

**회전 공식 설명**:
- 90도 시계 방향 회전: `(x, y) → (-y, x)`
- 예: `(1, 0)` → `(0, 1)`, `(0, 1)` → `(-1, 0)`
- Local Position을 회전시키므로, 부모 위치는 그대로 유지됩니다

## 🔗 이전 단계와의 연결

이 단계에서는 **3단계에서 만든 프리팹**을 사용합니다:
- 3단계: Unity에서 프리팹 직접 만들기 (I, O, T, S, Z, J, L)
- 4단계: 프리팹으로 생성된 블록을 이동/회전

**2단계에서 만든 GameBoard**도 사용합니다:
- `gameBoard.width`, `gameBoard.height`: 보드 크기 확인
- 나중에 `gameBoard.IsCellEmpty()`: 충돌 확인 (6단계에서 사용)

**작동 방식**:
- 프리팹을 Instantiate하면 자식 블록들이 함께 생성됨
- 부모(TetrisBlock)의 `transform.position`을 변경하면 자식도 함께 이동
- 자식 블록의 `localPosition`을 변경하면 회전 효과

## 💡 이 방식의 장점

**참고 블로그 방식 (프리팹 기반)**:
- ✅ **간단함**: `transform.position` 직접 변경
- ✅ **직관적**: Unity 좌표를 그대로 사용
- ✅ **Mathf.RoundToInt()**: 소수점을 정수로 변환하여 그리드에 맞춤
- ✅ **자식 블록 활용**: `transform.GetChild()`로 직접 접근
- ❌ Dictionary/List 불필요: 2차원 배열만 알면 됨

## 💡 이번 단계에서 익히는 개념

- **+= (복합 대입)** = "기존 값에 더해서 다시 넣기". `fallTimer += Time.deltaTime`, `transform.position += Vector3.left` 처럼 이번 단계에서 자주 씁니다. 위 **연산자 설명** 참고.
- **&& (그리고)** = 조건이 **모두 참**일 때만 true. **|| (또는)** = 조건 **하나라도 참**이면 true.  
  **범위 밖인가?** → 하나라도 해당되면 밖 → **||** 사용. **범위 안인가?** → 모두 만족해야 안 → **&&** 사용. ValidMove는 "범위 밖인가?"를 묻므로 **||** 를 씁니다. 위 **연산자 설명** 참고.
- **저장소를 다루는 함수** = 어떤 변수(저장소)의 값을 읽거나 바꾸는 함수  
  예: `MoveLeft()` 는 `position` 이라는 저장소를 바꿉니다.  
  이런 식으로 "저장소 + 그걸 다루는 함수"가 짝이 됩니다.
- **Start()** = 준비가 끝난 뒤 한 번 (예: GameBoard 찾기, 초기 위치)  
  **Update()** = 매 프레임 반복 (예: 자동 낙하 타이머)

**📌 복기**: **변수**(저장소)를 다루는 함수 = **메소드**(MoveLeft, MoveRight, Rotate). 한 번에 이해 못했어도 [변수](../참고자료/개념/변수.md) · [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                            | 이번 단계와의 연결                                                   |
| ---------------------------------------------------- | -------------------------------------------------------------------- |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md)    | 저장소(멤버)와 그걸 다루는 함수(메소드). AddScore 실습으로 짝 느끼기 |
| [Vector](../참고자료/개념/Vector.md)                 | Vector3.left, right, down. 위치·방향 실습                            |
| [Time.deltaTime](../참고자료/개념/Time-deltaTime.md) | 자동 낙하 타이머. 1초마다 실행하는 실습                              |
| [충돌 감지](../참고자료/개념/충돌감지.md)            | ValidMove처럼 "이동 가능한지" 확인. CanMoveTo 실습                   |

## 📺 UI 기본 구조 만들기 (선택사항, 7단계에서 자세히 설명)

게임을 테스트하면서 점수를 확인하려면 UI가 필요합니다. 7단계에서 자세히 설명하지만, 미리 만들어두고 싶다면:

1. **Canvas 생성**
   - Hierarchy에서 우클릭 → **"UI > Canvas"** 선택

2. **기본 Text 생성 (나중에 사용)**
   - Canvas 선택 후 우클릭 → **"UI > Text - TextMeshPro"** 또는 **"UI > Legacy > Text"**
   - 이름: "ScoreText"
   - Text: "Score: 0"
   - 위치: Pos X: 400, Pos Y: 200

**참고**: UI는 7단계에서 자세히 설명합니다. 지금은 게임 로직에 집중하세요!

## ✅ 확인 사항

- [ ] 블록이 좌우로 이동하는가?
- [ ] 블록이 자동으로 낙하하는가?
- [ ] 회전 기능이 작동하는가?

## 📖 기초 개념 학습으로 이어가기

위 표의 **기초 개념 학습**을 진행한 뒤, 좌표·게임 흐름이 궁금하면 [좌표 처리 가이드](../참고자료/좌표처리-간단가이드.md), [프로그램 처리 흐름](../참고자료/프로그램처리흐름설계.md)에서 점진적으로 이어가세요.

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 3단계 - 테트리스 블록 만들기](./3단계-테트리스-블록-만들기.md) | [다음 단계: 5단계 - 입력 처리 →](./5단계-입력-처리.md)
