---
layout: default
title: 4단계 - 블록 이동 구현
---

# 4단계: 블록 이동 구현

## 🎯 이 단계에서 배울 것

- 블록의 좌우 이동
- 자동 낙하 구현
- 회전 기능 구현
- 충돌 감지

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                                                                         | 설명                                                                                                              |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **내가 만드는 것**      | **TetrisBlock**의 **MoveLeft/MoveRight/MoveDown/Rotate**, **ValidMove**                                                | 우리가 정의하는 "이동·회전 규칙"과 "이동 가능한지" 판단. **테트리스 규칙**은 전부 우리 로직.                      |
| **엔진(API)이 주는 것** | **MonoBehaviour**, **Start()/Update()**, **FindObjectOfType**, **Transform**, **Time.deltaTime**, **Mathf.RoundToInt** | Unity가 제공. **Update()**는 엔진이 "매 프레임" 불러 주는 **자리**, **Time.deltaTime**은 엔진이 주는 "경과 시간". |

**왜 엔진 것을 쓰나?**  
게임이 매 프레임 돌아가려면 **Update()** 같은 **엔진이 정해 둔 자리**에 우리 코드를 넣어야 합니다. **Time.deltaTime**은 "프레임 간 시간"을 엔진이 알려 주므로, 우리는 **그걸 이용해 "1초에 한 칸"** 같은 규칙만 짜면 됩니다. 이동·회전 **로직**은 우리가 만들고, **위치 읽기/쓰기**는 엔진 타입(Transform)을 씁니다.

---

## 📝 실습 내용

**📐 이번 단계 후 예시 구조 (가이드)**  
Spawner를 쓰면 **씬**에는 아래처럼 오브젝트가 있고, **Play** 시 Spawner가 블록을 하나 생성합니다. **이 예시로 Hierarchy(위치)를 체크**해 보세요.

```
씬 (Tetris)
├─ Main Camera
├─ GameBoard
├─ Spawner            ← Spawner (Script), Block Prefab·Spawn Point 연결
│  └─ (Spawn Point 등)  ← 빈 오브젝트, Position (5, 18, 0) 권장. Inspector에서 Spawner에 드래그 연결
└─ (Play 시) 스폰된 블록 1개   ← TetrisBlock 스크립트 붙은 프리팹 인스턴스
```

**전체 시스템·클래스 구조** → [시스템 설계 개요](../참고자료/시스템설계개요.md)

---

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**  
**📌 발음**: Hierarchy, Spawner, Inspector 등 → **[영어 용어 발음·표기](../참고자료/영어-용어-발음-표기.md)** (한글 발음만 보셔도 됩니다)

### 0. Spawner 점증적 도입 — 블록을 씬에 두기

이동·회전을 테스트하려면 **씬에 블록이 하나 있어야** 합니다. **Spawner**를 4단계에서 **점증적으로** 도입합니다. 기능이 완벽하지 않아도 괜찮습니다. 지금은 "시작할 때 블록 한 개만 생성"만 하고, 8단계에서 반복·랜덤·게임 오버를 추가합니다.

**방법 A — 수동**: Hierarchy에 **3단계에서 만든 프리팹**(예: I_Block)을 **Project에서 끌어다 놓기**.  
→ Spawner 없이 바로 이동·회전 테스트할 때 사용.

**방법 B — Spawner 도입(점증적)**: **Spawner** 클래스를 4단계에서 만들고, Start에서 **블록 한 개만** Instantiate 합니다.  
→ 나중에 8단계에서 같은 Spawner에 반복·랜덤·게임 오버만 붙이면 됩니다.

**방법 B 사용 시** — Spawner를 최소 기능으로 둡니다.

1. **C# 스크립트 생성**  
   - 이름: `Spawner`

2. **다음 코드 작성** (4단계용 최소 버전)
```csharp
using UnityEngine;

public class Spawner : MonoBehaviour   // [MonoBehaviour 상속]
{
    public GameObject blockPrefab;   // [우리 멤버] Inspector에서 3단계 프리팹 연결
    public Transform spawnPoint;      // [우리 멤버] 생성 위치 (Inspector에서 연결)

    void Start()   // [Unity가 호출] 상속받은 메소드 — 엔진이 한 번 호출
    {
        SpawnNext();   // [우리 메소드]
    }

    public void SpawnNext()   // [우리 메소드] 4단계: 블록 한 개만. 8단계에서 랜덤·게임오버 추가
    {
        if (blockPrefab == null) return;   // blockPrefab: [우리 멤버]
        Vector3 pos = spawnPoint != null ? spawnPoint.position : new Vector3(5f, 18f, 0f);   // spawnPoint: [우리 멤버], position: [Unity 프로퍼티]
        Instantiate(blockPrefab, pos, Quaternion.identity);   // Instantiate: [Unity API]
        Debug.Log($"블록 생성됨 (Spawner) — 위치: {pos}");   // Debug.Log: [Unity API]
    }
}
```

3. **빈 GameObject 생성** (이름: "Spawner"**(읽는 법: 스포너)**) → 위 스크립트 추가  
   - **[Hierarchy]** (읽는 법: 하이어러키) 빈 공간 **우클릭** → **Create Empty** → 이름 **Spawner** 로 변경 → **[Hierarchy > Spawner]**  
   - **[Project > Assets > Scripts > Spawner.cs]** 를 **[Hierarchy > Spawner]** 위로 **드래그**하여 스크립트 추가  
4. **Spawn Point**  
   - **[Hierarchy]** 빈 공간 **우클릭** → **Create Empty** → 이름 **SpawnPoint** 로 변경 → **[Hierarchy > SpawnPoint]**  
   - **[Inspector > SpawnPoint > Transform > Position]** = **(5, 18, 0)** (권장)  
   - **[Hierarchy > Spawner]** 클릭 → **[Inspector > Spawner (Script) > Spawn Point]** 칸에 **[Hierarchy > SpawnPoint]** 를 **드래그**하여 연결  
5. **Block Prefab**  
   - **[Hierarchy > Spawner]** 클릭 → **[Inspector > Spawner (Script) > Block Prefab]** 칸에 **[Project > Assets > Prefabs > I_Block]** (또는 사용하는 블록)을 **드래그**하여 연결  
   - **📌 연결 조건**: 넣는 프리팹의 **루트 오브젝트**(예: I_Block)에 **TetrisBlock 스크립트가 붙어 있어야** 합니다. 3단계 [TetrisBlock 스크립트를 프리팹에 추가](./3단계-테트리스-블록-만들기.md) 참고. 없으면 스폰된 블록으로 이동·회전이 동작하지 않습니다.  
6. Play → Spawner가 블록 한 개를 생성하고, 그 블록으로 이동·회전 테스트

**📌 생성 위치 확인** (이상하게 보일 때 점검)  
- **블록이 안 보이거나 잘못된 곳에 생성되면**:  
  1. **[Hierarchy > SpawnPoint]** 선택 → **[Inspector > SpawnPoint > Transform > Position]** 이 **(5, 18, 0)** 인지 확인  
  2. **[Hierarchy > GameBoard]** 선택 → **[Inspector > Game Board (Script) > Width / Height]** 가 10, 20인지 확인  
  3. **[Hierarchy > Main Camera]** 와 **[Inspector > Camera > Size]** 등으로 보드 영역이 보이는지 확인 → 5단계 **[테스트 전 필수 설정](./5단계-입력-처리.md#테스트-전-필수-설정-카메라게임-보드-표현)** 참고.  
- **Console**에 "블록 생성됨 (Spawner)" 로그가 나오면 생성은 된 것이고, **화면에 안 보이는 경우**는 대부분 카메라 위치/Size 문제입니다.

**점증적 도입 정리**:
- **4단계**: Spawner 도입 — `SpawnNext()`로 블록 **한 개만** 생성 (완벽하지 않아도 됨)
- **8단계**: 같은 Spawner에 **프리팹 배열·Random.Range·게임 오버·LockPiece에서 SpawnNext() 호출** 추가 → [8단계 - 게임 완성](./8단계-게임-완성.md)

개념만 익히려면 [Instantiate / Destroy](../참고자료/개념/Instantiate-Destroy.md)를 참고하세요.

---

### 1. GameBoard 연결 및 기본 구조

**📌 소스코드 구분 표기 (멤버·메소드·상속)**  
코드에서 **내가 만든 것**과 **Unity에서 오는 것**을 구분할 수 있도록 아래처럼 주석을 달아 둡니다. 초보자는 주석만 보고 "우리 것 / 상속·API"를 구분하면 됩니다.

| 표기                                | 의미                                                                                                                                                        |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **[우리 멤버]** / **[우리 변수]**   | 우리가 선언한 필드(변수). 예: `gameBoard`, `fallSpeed`, `width`, `grid`                                                                                     |
| **[우리 메소드]** / **[우리 구현]** | 우리가 만든 함수. 예: `ValidMove()`, `MoveLeft()`, `AddToGrid()`                                                                                            |
| **[Unity가 호출]**                  | `Start()`, `Update()`, `Awake()` — **이름을 맞춰 쓰면** Unity 엔진이 **알아서** 부르는 메소드. **상속받은 메소드**입니다.                                   |
| **[MonoBehaviour 상속]**            | `class TetrisBlock : MonoBehaviour` — Unity가 제공하는 **부모 클래스**를 상속. 그래서 `transform`, `gameObject`, `Start()`, `Update()` 등을 쓸 수 있습니다. |
| **[Unity 프로퍼티]**                | 괄호 없이 쓰는 값. Unity가 제공. 예: `transform`, `position`, `Time.deltaTime`, `gameObject`, `.text`                                                       |
| **[Unity API]**                     | Unity가 제공하는 **함수**. 우리는 호출만. 예: `FindObjectOfType()`, `GetChild()`, `Input.GetKey()`, `Instantiate()`, `Destroy()`                            |

---

`Assets/Scripts/TetrisBlock.cs`를 다음과 같이 작성합니다:

```csharp
using UnityEngine;

public class TetrisBlock : MonoBehaviour   // [MonoBehaviour 상속]
{
    private GameBoard gameBoard;   // [우리 멤버]
    public float fallSpeed = 1f;   // [우리 멤버] 낙하 속도 (초)
    private float fallTimer = 0f;  // [우리 멤버]

    void Start()   // [Unity가 호출] 상속받은 메소드 — 엔진이 한 번 호출
    {
        gameBoard = FindObjectOfType<GameBoard>();   // [Unity API]
    }

    void Update()   // [Unity가 호출] 상속받은 메소드 — 매 프레임 엔진이 호출
    {
        fallTimer += Time.deltaTime;   // Time.deltaTime: [Unity 프로퍼티]
        if (fallTimer >= fallSpeed)
        {
            MoveDown();   // [우리 메소드]
            fallTimer = 0f;
        }
    }
}
```

### 2. 이동 가능한지 확인하는 함수

**참고 블로그 방식**: 자식 블록들의 위치를 직접 확인합니다.

```csharp
bool ValidMove(Vector3 offset)   // [우리 메소드] 이동 가능한지 확인
{
    for (int i = 0; i < transform.childCount; i++)   // transform, childCount: [Unity 프로퍼티] 상속
    {
        Transform child = transform.GetChild(i);      // GetChild(i): [Unity API]
        Vector3 newPos = child.position + offset;     // position: [Unity 프로퍼티]
        int roundX = Mathf.RoundToInt(newPos.x);     // Mathf.RoundToInt: [Unity API]
        int roundY = Mathf.RoundToInt(newPos.y);
        if (roundX < 0 || roundX >= gameBoard.width || roundY < 0 || roundY >= gameBoard.height)   // gameBoard.width, height: [우리 멤버] GameBoard 쪽
            return false;
    }
    return true;
}
```

**Mathf.RoundToInt() 설명**:
- 소수점을 반올림하여 정수로 만듭니다
- 예: 5.2 → 5, 5.7 → 6, 10.8 → 11
- Unity 좌표가 소수점일 수 있으므로 정수로 변환하여 그리드에 맞춥니다

### 📌 연산자 설명: += , && , || (이번 단계에서 자주 쓰는 것)

이번 단계 코드에서 **+=** , **&&** , **||** 가 나옵니다. 의미를 알아두면 읽기 편합니다.

#### += 연산자 (복합 대입) — 쉽게 이해하기

**쉽게 말하면**: **저장소(변수)에 있는 값에, 조금을 더해서, 그 결과를 다시 그 저장소에 넣는 것**입니다.

**두 가지 쓰는 법 (똑같은 뜻)**  
- `fallTimer = fallTimer + Time.deltaTime;`  ← "지금 fallTimer에 Time.deltaTime을 더한 값을, fallTimer에 넣는다"  
- `fallTimer += Time.deltaTime;`  ← 위와 **완전히 같은 뜻**인데, 짧게 쓴 것입니다.

즉, **+=** 는 "더한 다음에, 그 결과를 다시 그 변수에 넣는다"를 **한 번에** 쓰는 기호라고 보면 됩니다.

**숫자로 보기 (자동 낙하)**  
- 처음: `fallTimer` = 0  
- 1프레임 후: `fallTimer += 0.016` → fallTimer = 0 + 0.016 = **0.016**  
- 2프레임 후: `fallTimer += 0.016` → fallTimer = 0.016 + 0.016 = **0.032**  
- … 이렇게 **조금씩 더해져서** 1초(예: 1.0)가 되면 MoveDown()을 부르고, fallTimer를 0으로 돌립니다.

**이동할 때**  
- `transform.position += Vector3.left;`  
  → "**지금 위치**" + "**왼쪽 한 칸**" = **새 위치** → 그 새 위치를 다시 position에 넣기 → 블록이 왼쪽으로 한 칸 이동한 것처럼 보입니다.

**헷갈리면**: "**더하기**를 한 다음, 그 **결과를 다시 그 변수(저장소)에 넣는 것**"이라고만 생각해도 됩니다. `a += b` = "a에 b를 더해서, 다시 a에 넣기."

#### && (그리고) 와 || (또는) — 쉽게 이해하기

**|| (또는) — 쉽게 말하면**  
- **"둘 중 하나라도 맞으면 된다"** 라고 생각하면 됩니다.  
  예: "오늘 **비 오거나** 눈 오면 우산 챙긴다" → 비 오기 **또는** 눈 오기 **하나라도** 해당되면 우산 챙김.  
- 코드에서는: `A || B` → **A가 참이거나 B가 참이면** 결과가 true. **둘 다 거짓일 때만** false.

**&& (그리고) — 쉽게 말하면**  
- **"둘 다 맞아야 한다"** 라고 생각하면 됩니다.  
  예: "x가 0 이상 **이고** 10 미만이다" → **둘 다** 만족해야 true.

**ValidMove에서는 "범위 밖인가?"를 묻습니다.**  
- 범위 **밖** = "x가 너무 작다 **또는** x가 너무 크다 **또는** y가 너무 작다 **또는** y가 너무 크다"  
  → **이 중 하나라도** 해당되면 "범위 밖"이에요. 그래서 **|| (또는)** 를 씁니다.  
- 읽는 법:  
  `roundX < 0 || roundX >= width || ...`  
  = "x가 0 미만 **이거나**, x가 width 이상 **이거나**, … **하나라도** 참이면" → 범위 밖 → false(이동 불가).

**반대로 "범위 안"이면**  
- "x가 0 이상 **이고** width 미만 **이고** y가 0 이상 **이고** height 미만" → **모두** 만족해야 하므로 **&&** 를 씁니다.

**정리**  
| 묻는 말          | 쉽게 말하면          | 연산자          |
| ---------------- | -------------------- | --------------- |
| 범위 **밖**인가? | 하나라도 해당되면 밖 | **\|\|** (또는) |
| 범위 **안**인가? | 모두 만족해야 안     | **&&** (그리고) |

**헷갈리면**: **||** = "**또는**" = **하나라도 맞으면** 된다. **&&** = "**그리고**" = **다 맞아야** 된다.

### 3. 이동 함수 구현

```csharp
public void MoveLeft()   // [우리 메소드]
{
    if (ValidMove(Vector3.left))   // ValidMove: [우리 메소드], Vector3.left: [Unity 프로퍼티]
        transform.position += Vector3.left;   // transform, position: [Unity 프로퍼티]
}
public void MoveRight()   // [우리 메소드]
{
    if (ValidMove(Vector3.right))
        transform.position += Vector3.right;
}
public void MoveDown()   // [우리 메소드]
{
    if (ValidMove(Vector3.down))
        transform.position += Vector3.down;
    // else: 6단계에서 LockPiece() 호출
}
```

**작동 방식**:
1. `ValidMove()`로 이동 가능한지 확인
2. 가능하면 `transform.position`을 직접 변경
3. 부모가 이동하면 자식 블록들도 함께 이동 (Unity의 Transform 시스템)

### 4. 회전 기능 구현

**참고 블로그 방식**: 각 자식 블록의 Local Position을 회전시킵니다.

```csharp
public void Rotate()   // [우리 메소드]
{
    Vector3[] newLocalPositions = new Vector3[transform.childCount];   // transform.childCount: [Unity 프로퍼티]
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);   // GetChild(i): [Unity API]
        Vector3 localPos = child.localPosition;    // localPosition: [Unity 프로퍼티]
        float newX = -localPos.y;
        float newY = localPos.x;
        newLocalPositions[i] = new Vector3(newX, newY, 0);
    }
    bool canRotate = true;
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);   // [Unity API]
        Vector3 newWorldPos = transform.position + newLocalPositions[i];   // transform.position: [Unity 프로퍼티]
        int roundX = Mathf.RoundToInt(newWorldPos.x);   // [Unity API]
        int roundY = Mathf.RoundToInt(newWorldPos.y);
        if (roundX < 0 || roundX >= gameBoard.width || roundY < 0 || roundY >= gameBoard.height)   // gameBoard.width, height: [우리 멤버] GameBoard 쪽
        {
            canRotate = false;
            break;
        }
    }
    if (canRotate)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform child = transform.GetChild(i);
            child.localPosition = newLocalPositions[i];   // localPosition: [Unity 프로퍼티]
        }
    }
}
```

**📌 복기**: `newLocalPositions` 는 **배열**(같은 타입을 순서대로 저장). 한 번에 이해 못했어도 [배열](../참고자료/개념/배열.md)에서 다시 실습해 보세요.

**회전 공식 설명**:
- 90도 시계 방향 회전: `(x, y) → (-y, x)`
- 예: `(1, 0)` → `(0, 1)`, `(0, 1)` → `(-1, 0)`
- Local Position을 회전시키므로, 부모 위치는 그대로 유지됩니다

## 🔗 이전 단계와의 연결

**이 섹션은 실습이 아닙니다.** 따로 할 일이나 체크할 항목은 없습니다. "이 단계가 이전 단계와 어떻게 이어지는지"만 **참고**로 정리한 것이므로, 궁금할 때만 읽으면 됩니다.

| 단계      | 이 단계에서 하는 일                             | 4단계와의 연결                                                                                                              |
| --------- | ----------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **2단계** | GameBoard, width/height, grid, IsValidPosition  | 4단계 TetrisBlock이 `gameBoard.width`, `gameBoard.height`로 범위 검사 (ValidMove)                                           |
| **3단계** | 블록 프리팹(I_Block, O_Block 등) 만들기         | 4단계에서 **Spawner**가 그 프리팹을 Instantiate로 씬에 하나 생성 → 그 블록을 이동·회전 (위 **0. Spawner 점증적 도입** 참고) |
| **4단계** | TetrisBlock 이동·회전 + **Spawner 점증적 도입** | Spawner가 Start에서 **블록 한 개만** Instantiate. 블록은 수동으로 둘 수도 있음                                              |

**4단계에서 블록이 씬에 오는 방법** (둘 중 하나):
- **수동**: Hierarchy에 3단계 프리팹을 Project에서 끌어다 놓기
- **Spawner(점증적)**: **Spawner** 클래스를 두고 `SpawnNext()`로 블록 한 개만 Instantiate (위 **0. Spawner 점증적 도입 — 방법 B**에 코드 있음)

**이후 단계**:
- 6단계: `gameBoard.IsCellEmpty()`, `AddToGrid()`, `LockPiece()` 로 블록 고정
- **8단계: Spawner 확장** — 4단계에서 만든 Spawner에 **프리팹 배열·랜덤·게임 오버·LockPiece에서 SpawnNext() 호출** 추가. [8단계 - 게임 완성](./8단계-게임-완성.md) 참고.

**작동 방식**:
- 프리팹을 **Instantiate**하면 자식 블록들이 함께 생성됨
- 부모(TetrisBlock)의 `transform.position`을 변경하면 자식도 함께 이동
- 자식 블록의 `localPosition`을 변경하면 회전 효과

## 💡 이 방식의 장점

**참고 블로그 방식 (프리팹 기반)**:
- ✅ **간단함**: `transform.position` 직접 변경
- ✅ **직관적**: Unity 좌표를 그대로 사용
- ✅ **Mathf.RoundToInt()**: 소수점을 정수로 변환하여 그리드에 맞춤
- ✅ **자식 블록 활용**: `transform.GetChild()`로 직접 접근
- ❌ Dictionary/List 불필요: 2차원 배열만 알면 됨

## 💡 이번 단계에서 익히는 개념

- **+= (복합 대입)** = "기존 값에 더해서 다시 넣기". `fallTimer += Time.deltaTime`, `transform.position += Vector3.left` 처럼 이번 단계에서 자주 씁니다. 위 **연산자 설명** 참고.
- **&& (그리고)** = 조건이 **모두 참**일 때만 true. **|| (또는)** = 조건 **하나라도 참**이면 true.  
  **범위 밖인가?** → 하나라도 해당되면 밖 → **||** 사용. **범위 안인가?** → 모두 만족해야 안 → **&&** 사용. ValidMove는 "범위 밖인가?"를 묻므로 **||** 를 씁니다. 위 **연산자 설명** 참고.
- **저장소를 다루는 함수** = 어떤 변수(저장소)의 값을 읽거나 바꾸는 함수  
  예: `MoveLeft()` 는 `position` 이라는 저장소를 바꿉니다.  
  이런 식으로 "저장소 + 그걸 다루는 함수"가 짝이 됩니다.
- **Start()** = 준비가 끝난 뒤 한 번 (예: GameBoard 찾기, 초기 위치)  
  **Update()** = 매 프레임 반복 (예: 자동 낙하 타이머)

**📌 복기**: **변수**(저장소)를 다루는 함수 = **메소드**(MoveLeft, MoveRight, Rotate). 한 번에 이해 못했어도 [변수](../참고자료/개념/변수.md) · [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 단계가 올라갈수록 같은 개념이 조금씩 확장되므로, 차근차근 따라 하면 됩니다.

| 개념 문서                                            | 이번 단계와의 연결                                                   |
| ---------------------------------------------------- | -------------------------------------------------------------------- |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md)    | 저장소(멤버)와 그걸 다루는 함수(메소드). AddScore 실습으로 짝 느끼기 |
| [Vector](../참고자료/개념/Vector.md)                 | Vector3.left, right, down. 위치·방향 실습                            |
| [Time.deltaTime](../참고자료/개념/Time-deltaTime.md) | 자동 낙하 타이머. 1초마다 실행하는 실습                              |
| [충돌 감지](../참고자료/개념/충돌감지.md)            | ValidMove처럼 "이동 가능한지" 확인. CanMoveTo 실습                   |

## 📐 Transform 확장 설명 & 4단계 확장 실습

4단계에서 **position**, **localPosition**, **GetChild**, **childCount** 등을 사용합니다. **스케일(scale)**, **로테이션(rotation)**, **월드 vs 부모 기준(local)** 등은 아래에서 확장해서 볼 수 있습니다.

- **Transform 개념 확장** (스케일, 로테이션, localPosition, 부모·자식 정리)  
  → [Transform (개념 확장)](../참고자료/개념/Transform.md)

**4단계 확장 실습**은 **변수 → 멤버 → 배열** 순으로 점증적으로 실습할 수 있는 **개별 파일**입니다. **이전 단계(1~3단계)를 다 이해하지 못했더라도** 각 실습 파일만 따라 하면 진행할 수 있도록 되어 있고, 필요할 때만 **이전 단계·개념 문서 링크**를 참고하면 됩니다.

| 확장 실습                                                                  | 내용                                             | 이전 단계 링크 (필요 시 참고)                                                                                   |
| -------------------------------------------------------------------------- | ------------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| [01 - 변수와 Transform](../참고자료/4단계-확장-실습/01-변수와Transform.md) | 변수에 위치·크기 저장 후 Transform에 적용        | [1단계](./1단계-Unity-기초.md), [4단계](./4단계-블록-이동-구현.md), [변수](../참고자료/개념/변수.md)            |
| [02 - 멤버와 Transform](../참고자료/4단계-확장-실습/02-멤버와Transform.md) | 멤버 변수 + 메소드로 이동 (MoveRight 등)         | [4단계](./4단계-블록-이동-구현.md), [멤버와 메소드](../참고자료/개념/멤버와메소드.md)                           |
| [03 - 배열과 Transform](../참고자료/4단계-확장-실습/03-배열과Transform.md) | 배열에 자식 localPosition 저장 후 90도 회전 적용 | [4단계](./4단계-블록-이동-구현.md), [배열](../참고자료/개념/배열.md), [회전 수학](../참고자료/개념/회전수학.md) |

**📐 단계별 확장 실습 전체 목차** (1~8단계 분산): [단계별 확장 실습 (목차)](../참고자료/확장-실습/README.md)

## 📺 UI 기본 구조 만들기 (선택사항, 7단계에서 자세히 설명)

게임을 테스트하면서 점수를 확인하려면 UI가 필요합니다. 7단계에서 자세히 설명하지만, 미리 만들어두고 싶다면:

1. **Canvas 생성**
   - Hierarchy에서 우클릭 → **"UI > Canvas"** 선택

2. **기본 Text 생성 (나중에 사용)**
   - Canvas 선택 후 우클릭 → **"UI > Text - TextMeshPro"** 또는 **"UI > Legacy > Text"**
   - 이름: "ScoreText"
   - Text: "Score: 0"
   - 위치: Pos X: 400, Pos Y: 200

**참고**: UI는 7단계에서 자세히 설명합니다. 지금은 게임 로직에 집중하세요!

## ✅ 확인 사항

- [ ] 블록이 좌우로 이동하는가?
- [ ] 블록이 자동으로 낙하하는가?
- [ ] 회전 기능이 작동하는가?

## 📖 기초 개념 학습으로 이어가기

위 표의 **기초 개념 학습**을 진행한 뒤, 좌표·게임 흐름이 궁금하면 [좌표 처리 가이드](../참고자료/좌표처리-간단가이드.md), [프로그램 처리 흐름](../참고자료/프로그램처리흐름설계.md)에서 점진적으로 이어가세요.

**✅ 다음 단계 전 점검**: 작업 씬이 **Tetris**인지 **재차 확인**하세요. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾼 뒤 다음 단계로 넘어가세요.

---

[← 이전 단계: 3단계 - 테트리스 블록 만들기](./3단계-테트리스-블록-만들기.md) | [다음 단계: 5단계 - 입력 처리 →](./5단계-입력-처리.md)
