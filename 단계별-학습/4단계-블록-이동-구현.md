---
layout: default
title: 4단계 - 블록 이동 구현
---

# 4단계: 블록 이동 구현

## 🎯 이 단계에서 배울 것

- 블록의 좌우 이동
- 자동 낙하 구현
- 회전 기능 구현
- 충돌 감지

## 📝 실습 내용

### 1. GameBoard 연결 및 기본 구조

`Assets/Scripts/Tetromino.cs`를 다음과 같이 작성합니다:

```csharp
using UnityEngine;

public class Tetromino : MonoBehaviour
{
    private GameBoard gameBoard;
    public float fallSpeed = 1f;  // 낙하 속도 (초)
    private float fallTimer = 0f;
    
    void Start()
    {
        // GameBoard 찾기
        gameBoard = FindObjectOfType<GameBoard>();
        
        // 초기 위치는 Spawner에서 설정하거나 여기서 설정
        // transform.position은 Unity 씬에서 설정된 Spawner 위치 사용
    }
    
    void Update()
    {
        // 자동 낙하
        fallTimer += Time.deltaTime;
        if (fallTimer >= fallSpeed)
        {
            MoveDown();
            fallTimer = 0f;
        }
    }
}
```

### 2. 이동 가능한지 확인하는 함수

**참고 블로그 방식**: 자식 블록들의 위치를 직접 확인합니다.

```csharp
// 이동 가능한지 확인하는 함수
bool ValidMove(Vector3 offset)
{
    // 모든 자식 블록 확인
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);
        
        // 이동 후 위치 계산
        Vector3 newPos = child.position + offset;
        
        // Unity 좌표를 정수로 반올림 (게임 보드 그리드에 맞추기)
        int roundX = Mathf.RoundToInt(newPos.x);
        int roundY = Mathf.RoundToInt(newPos.y);
        
        // 보드 범위 확인
        if (roundX < 0 || roundX >= gameBoard.width || 
            roundY < 0 || roundY >= gameBoard.height)
        {
            return false;  // 범위 밖!
        }
        
        // 이미 블록이 있는지 확인 (6단계에서 구현)
        // if (!gameBoard.IsCellEmpty(roundX, roundY))
        //     return false;
    }
    
    return true;  // 이동 가능!
}
```

**Mathf.RoundToInt() 설명**:
- 소수점을 반올림하여 정수로 만듭니다
- 예: 5.2 → 5, 5.7 → 6, 10.8 → 11
- Unity 좌표가 소수점일 수 있으므로 정수로 변환하여 그리드에 맞춥니다

### 3. 이동 함수 구현

```csharp
public void MoveLeft()
{
    if (ValidMove(Vector3.left))  // 왼쪽으로 1칸
    {
        transform.position += Vector3.left;
    }
}

public void MoveRight()
{
    if (ValidMove(Vector3.right))  // 오른쪽으로 1칸
    {
        transform.position += Vector3.right;
    }
}

public void MoveDown()
{
    if (ValidMove(Vector3.down))  // 아래로 1칸
    {
        transform.position += Vector3.down;
    }
    else
    {
        // 더 이상 내려갈 수 없으면 블록 고정 (6단계에서 구현)
        // LockPiece();
    }
}
```

**작동 방식**:
1. `ValidMove()`로 이동 가능한지 확인
2. 가능하면 `transform.position`을 직접 변경
3. 부모가 이동하면 자식 블록들도 함께 이동 (Unity의 Transform 시스템)

### 4. 회전 기능 구현

**참고 블로그 방식**: 각 자식 블록의 Local Position을 회전시킵니다.

```csharp
public void Rotate()
{
    // 회전 후 위치들을 저장할 배열 (자식 개수만큼)
    Vector3[] newLocalPositions = new Vector3[transform.childCount];
    
    // 각 자식 블록의 Local Position을 90도 회전
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);
        Vector3 localPos = child.localPosition;
        
        // 90도 시계 방향 회전 공식: (x, y) → (-y, x)
        float newX = -localPos.y;
        float newY = localPos.x;
        newLocalPositions[i] = new Vector3(newX, newY, 0);
    }
    
    // 회전 후 위치가 유효한지 확인
    bool canRotate = true;
    for (int i = 0; i < transform.childCount; i++)
    {
        Transform child = transform.GetChild(i);
        Vector3 newWorldPos = transform.position + newLocalPositions[i];
        
        // Unity 좌표를 정수로 반올림
        int roundX = Mathf.RoundToInt(newWorldPos.x);
        int roundY = Mathf.RoundToInt(newWorldPos.y);
        
        // 보드 범위 확인
        if (roundX < 0 || roundX >= gameBoard.width || 
            roundY < 0 || roundY >= gameBoard.height)
        {
            canRotate = false;
            break;
        }
    }
    
    // 회전 가능하면 적용
    if (canRotate)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform child = transform.GetChild(i);
            child.localPosition = newLocalPositions[i];
        }
    }
}
```

**회전 공식 설명**:
- 90도 시계 방향 회전: `(x, y) → (-y, x)`
- 예: `(1, 0)` → `(0, 1)`, `(0, 1)` → `(-1, 0)`
- Local Position을 회전시키므로, 부모 위치는 그대로 유지됩니다

## 🔗 이전 단계와의 연결

이 단계에서는 **3단계에서 만든 프리팹**을 사용합니다:
- 3단계: Unity에서 프리팹 직접 만들기 (I, O, T, S, Z, J, L)
- 4단계: 프리팹으로 생성된 블록을 이동/회전

**2단계에서 만든 GameBoard**도 사용합니다:
- `gameBoard.width`, `gameBoard.height`: 보드 크기 확인
- 나중에 `gameBoard.IsCellEmpty()`: 충돌 확인 (6단계에서 사용)

**작동 방식**:
- 프리팹을 Instantiate하면 자식 블록들이 함께 생성됨
- 부모(Tetromino)의 `transform.position`을 변경하면 자식도 함께 이동
- 자식 블록의 `localPosition`을 변경하면 회전 효과

## 💡 이 방식의 장점

**참고 블로그 방식 (프리팹 기반)**:
- ✅ **간단함**: `transform.position` 직접 변경
- ✅ **직관적**: Unity 좌표를 그대로 사용
- ✅ **Mathf.RoundToInt()**: 소수점을 정수로 변환하여 그리드에 맞춤
- ✅ **자식 블록 활용**: `transform.GetChild()`로 직접 접근
- ❌ Dictionary/List 불필요: 2차원 배열만 알면 됨

## 📺 UI 기본 구조 만들기 (선택사항, 7단계에서 자세히 설명)

게임을 테스트하면서 점수를 확인하려면 UI가 필요합니다. 7단계에서 자세히 설명하지만, 미리 만들어두고 싶다면:

1. **Canvas 생성**
   - Hierarchy에서 우클릭 → **"UI > Canvas"** 선택

2. **기본 Text 생성 (나중에 사용)**
   - Canvas 선택 후 우클릭 → **"UI > Text - TextMeshPro"** 또는 **"UI > Legacy > Text"**
   - 이름: "ScoreText"
   - Text: "Score: 0"
   - 위치: Pos X: 400, Pos Y: 200

**참고**: UI는 7단계에서 자세히 설명합니다. 지금은 게임 로직에 집중하세요!

## ✅ 확인 사항

- [ ] 블록이 좌우로 이동하는가?
- [ ] 블록이 자동으로 낙하하는가?
- [ ] 회전 기능이 작동하는가?

## 📚 참고 자료

- [좌표 처리 가이드](../참고자료/좌표처리-간단가이드.md)
- [프로그램 처리 흐름](../참고자료/프로그램처리흐름설계.md)

---

[← 이전 단계: 3단계 - 테트로미노 블록 만들기](./3단계-테트로미노-블록-만들기.md) | [다음 단계: 5단계 - 입력 처리 →](./5단계-입력-처리.md)
