---
layout: default
title: 4단계 - 블록 이동 구현
---

# 4단계: 블록 이동 구현

## 🎯 이 단계에서 배울 것

- 블록의 좌우 이동
- 자동 낙하 구현
- 회전 기능 구현
- 충돌 감지

## 📝 실습 내용

### 1. 이동 함수 구현

```csharp
public class Tetromino : MonoBehaviour
{
    public float fallSpeed = 1f;  // 낙하 속도
    private float fallTimer = 0f;
    
    void Update()
    {
        // 자동 낙하
        fallTimer += Time.deltaTime;
        if (fallTimer >= fallSpeed)
        {
            MoveDown();
            fallTimer = 0f;
        }
    }
    
    public void MoveLeft()
    {
        // 왼쪽으로 이동
        transform.position += Vector3.left;
    }
    
    public void MoveRight()
    {
        // 오른쪽으로 이동
        transform.position += Vector3.right;
    }
    
    public void MoveDown()
    {
        // 아래로 이동
        transform.position += Vector3.down;
    }
}
```

### 2. 회전 기능

회전 수학 공식 적용

## ⚠️ 실제 구현과의 차이점

**블로그 설명**: 간단하게 이해하기 위해 `transform.position`을 직접 변경하는 방식으로 설명합니다.

**실제 구현**:
- 실제 코드에서는 **논리적 좌표** (`position` 변수)와 **Unity 월드 좌표** (`transform.position`)를 분리합니다:
  ```csharp
  // 실제 코드 (Tetromino.cs)
  private Vector2Int position;  // 논리적 좌표 (게임 보드 좌표계)
  
  public void MoveLeft()
  {
      position.x--;  // 논리적 좌표 변경
      UpdateVisualPosition();  // Unity 월드 좌표 업데이트
  }
  
  private void UpdateVisualPosition()
  {
      transform.position = new Vector3(position.x, position.y, 0);
  }
  ```
- 이렇게 분리하는 이유:
  - 논리적 좌표는 정수 (0, 1, 2...)로 정확하게 관리
  - Unity 월드 좌표는 소수점이 생길 수 있어서 정확도 문제 발생 가능
  - 충돌 감지와 그리드 저장 시 정수 좌표가 필요

**중요**:
- 블로그: `transform.position` 직접 변경 (간단한 설명)
- 실제: `position` 변수 변경 → `UpdateVisualPosition()` 호출 (정확한 좌표 관리)

## ✅ 확인 사항

- [ ] 블록이 좌우로 이동하는가?
- [ ] 블록이 자동으로 낙하하는가?
- [ ] 회전 기능이 작동하는가?

## 📚 참고 자료

- [좌표 처리 가이드](../참고자료/좌표처리-간단가이드)
- [프로그램 처리 흐름](../참고자료/프로그램처리흐름설계)

---

[← 이전 단계: 3단계 - 테트로미노 블록 만들기](./3단계-테트로미노-블록-만들기) | [다음 단계: 5단계 - 입력 처리 →](./5단계-입력-처리)
