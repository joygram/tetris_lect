---
layout: default
title: 실제 구현과의 차이점
---

# 실제 구현과의 차이점

이 블로그는 **학습 목적**으로 작성되었으며, 이해를 돕기 위해 일부 내용을 단순화했습니다.  
실제 프로젝트 코드와의 주요 차이점을 정리했습니다.

---

## 📍 좌표계 관련 차이점

### 1. 블록의 초기 위치

**블로그 설명**: 간단하게 (0, 0) 위치로 설명합니다.

**실제 구현** (`Tetromino.cs`):
```csharp
// 실제 코드
position = new Vector2Int(gameBoard.width / 2 - 1, gameBoard.height - 1);
// 즉, (4, 19) - 보드 중앙 상단에 배치됩니다
```

**차이점**:
- 블로그: (0, 0) - 왼쪽 아래 모서리
- 실제: (4, 19) - 보드 중앙 상단 (게임 시작 위치)

---

### 2. 논리적 좌표 vs Unity 월드 좌표

**블로그 설명**: 간단하게 `transform.position`을 직접 사용합니다.

**실제 구현**:
```csharp
// 실제 코드는 두 가지 좌표계를 분리합니다
private Vector2Int position;  // 논리적 좌표 (게임 보드 좌표계)

private void UpdateVisualPosition()
{
    // 논리적 좌표를 Unity 월드 좌표로 변환
    transform.position = new Vector3(position.x, position.y, 0);
}
```

**차이점**:
- 블로그: Unity 월드 좌표만 사용 (간단한 설명)
- 실제: 논리적 좌표와 Unity 월드 좌표 분리 (정확한 좌표 관리)

**왜 분리하나요?**
- 논리적 좌표는 정수 (0, 1, 2...)로 정확하게 관리
- Unity 월드 좌표는 소수점이 생길 수 있어서 정확도 문제 발생 가능
- 충돌 감지와 그리드 저장 시 정수 좌표가 필요

---

### 3. 블록의 상대 좌표

**블로그 설명**: 블록 내부의 상대 좌표를 (0, 0)부터 시작한다고 설명합니다.

**실제 구현**: ✅ 맞습니다!
```csharp
// 실제 코드 (Tetromino.cs)
private static readonly Dictionary<int, Vector2Int[]> shapes = new Dictionary<int, Vector2Int[]>
{
    {0, new Vector2Int[] {
        new Vector2Int(0, 0),  // 기준점
        new Vector2Int(1, 0),
        new Vector2Int(2, 0),
        new Vector2Int(3, 0)
    }},
    // ...
};
```

**차이점**: 없음 - 블로그 설명이 정확합니다.

---

## 🎮 게임 로직 관련 차이점

### 4. 이동 함수 구현

**블로그 설명**: `transform.position`을 직접 변경합니다.

**실제 구현**:
```csharp
// 실제 코드
public void MoveLeft()
{
    position.x--;  // 논리적 좌표 변경
    if (IsValidMove())  // 충돌 검사
    {
        UpdateVisualPosition();  // Unity 월드 좌표 업데이트
    }
    else
    {
        position.x++;  // 이동 취소
    }
}
```

**차이점**:
- 블로그: 이동만 구현 (간단한 설명)
- 실제: 이동 + 충돌 검사 + 롤백 기능 포함

---

### 5. 현재 블록 찾기

**블로그 설명**: `FindObjectOfType<Tetromino>()`를 매번 호출합니다.

**실제 구현**:
```csharp
// 실제 코드는 더 효율적으로 구현할 수 있습니다
private Tetromino currentTetromino;

void Update()
{
    if (currentTetromino == null)
        currentTetromino = FindObjectOfType<Tetromino>();
    
    // 입력 처리...
}
```

**차이점**:
- 블로그: 매번 `FindObjectOfType` 호출 (간단한 설명)
- 실제: 한 번 찾아서 변수에 저장 후 재사용 (성능 최적화)

---

## 📐 GameBoard 관련 차이점

### 6. GameBoard GameObject 위치

**블로그 설명**: Transform 위치를 (0, 0, 0)으로 설명합니다.

**실제 구현**:
- GameBoard GameObject의 Transform 위치는 Unity 씬에서 설정하는 값입니다
- 게임 보드의 **논리적 좌표계**는 항상 (0, 0)부터 시작합니다
- Unity **월드 좌표계**에서는 GameBoard GameObject의 위치에 따라 달라질 수 있습니다

**차이점**:
- 블로그: (0, 0, 0) 위치로 설명 (간단한 설명)
- 실제: Unity 씬에서 설정 가능하며, 논리적 좌표와 월드 좌표는 별개입니다

---

## 💡 왜 이런 차이가 있나요?

### 블로그의 목적
- **학습 목적**: 개념을 쉽게 이해하기 위해 단순화
- **단계별 진행**: 각 단계에서 핵심만 다룸
- **초보자 친화적**: 복잡한 세부사항은 제외

### 실제 구현의 특징
- **완전한 기능**: 모든 엣지 케이스 처리
- **성능 최적화**: 효율적인 알고리즘 사용
- **유지보수성**: 확장 가능한 구조

---

## 🔍 실제 코드 확인 방법

실제 구현을 확인하려면:

1. **프로젝트의 실제 코드 확인**
   - `Assets/Scripts/` 폴더의 실제 스크립트 파일 참고
   - 각 스크립트에 상세한 주석 포함

2. **주요 파일**
   - `GameBoard.cs`: 게임 보드 관리
   - `Tetromino.cs`: 블록 로직
   - `Spawner.cs`: 블록 생성
   - `InputHandler.cs`: 입력 처리
   - `GameController.cs`: 게임 제어

3. **참고 자료**
   - [시스템 설계 개요](../참고자료/시스템설계개요)
   - [프로그램 처리 흐름](../참고자료/프로그램처리흐름설계)
   - [좌표 처리 가이드](../참고자료/좌표처리-간단가이드)

---

## ✅ 정리

| 항목           | 블로그 설명           | 실제 구현                          |
| -------------- | --------------------- | ---------------------------------- |
| 블록 초기 위치 | (0, 0)                | (4, 19) - 중앙 상단                |
| 좌표계         | Unity 월드 좌표만     | 논리적 좌표 + Unity 월드 좌표 분리 |
| 이동 함수      | 간단한 이동           | 이동 + 충돌 검사 + 롤백            |
| 블록 찾기      | 매번 FindObjectOfType | 한 번 찾아서 캐싱                  |

**중요**: 블로그는 학습을 위한 가이드이며, 실제 프로젝트 코드를 참고하여 완전한 구현을 완성하세요!

---

[← 홈으로](./../index)
