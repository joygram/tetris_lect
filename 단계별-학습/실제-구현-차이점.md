---
layout: default
title: 실제 구현과의 차이점
---

# 실제 구현과의 차이점

이 블로그는 **학습 목적**으로 작성되었으며, 이해를 돕기 위해 일부 내용을 단순화했습니다.  
실제 프로젝트 코드와의 주요 차이점을 정리했습니다.

**참고**: 
- 이 강의 자료는 **웹사이트 기반 학습 가이드**를 참고하여 작성되었습니다
- 웹사이트 가이드에서는 좌표 처리를 단순화하여 설명하지만, 실제 구현에서는 더 정확한 좌표 처리 방식을 사용합니다
- 실제 프로젝트 코드는 `Assets/Scripts/` 폴더의 스크립트 파일을 참고하세요

---

## 📍 좌표계 관련 차이점

### 1. 블록의 초기 위치

**참고 블로그 방식**:
- 블록을 (0, 0) 위치에 배치한다고 설명
- 또는 Unity 씬에서 직접 위치를 설정 (Spawner 위치 사용)

**이 블로그 방식**:
- ✅ 참고 블로그 방식과 동일
- Spawner 위치를 사용하거나 게임 보드 중앙 상단에 배치
- Unity 씬에서 Spawner GameObject의 위치를 설정하면 그 위치에서 생성됨

---

### 2. 좌표 처리 방식

**참고 블로그 방식**:
- Unity 월드 좌표를 직접 사용
- 예: `transform.position = new Vector3(5, 17, 0)` - 블록을 (5, 17) 위치에 직접 배치
- 소수점이 생기면 `Mathf.RoundToInt()`로 반올림하여 정수로 변환
- 간단하고 직관적

**이 블로그 방식**:
- ✅ 참고 블로그 방식과 동일하게 Unity 월드 좌표 직접 사용
- ✅ `transform.position`을 직접 변경
- ✅ `Mathf.RoundToInt()`로 소수점을 정수로 변환

---

### 3. 블록 생성 방식

**참고 블로그 방식**:
- Unity 에디터에서 각 테트로미노를 프리팹으로 직접 만듦
- 프리팹에는 자식 큐브들이 Local Position으로 배치됨
- Spawner에서 프리팹을 Instantiate만 하면 됨
- Dictionary나 List 같은 고급 자료구조 불필요
- `transform.GetChild()`로 자식 블록 접근

**이 블로그 방식**:
- ✅ 참고 블로그 방식과 동일하게 프리팹 기반 사용
- ✅ 자식 블록을 직접 사용하는 방식

**차이점**: 없음 - 이 블로그도 참고 블로그 방식과 동일합니다.

---

## 🎮 게임 로직 관련 차이점

### 4. 이동 함수 구현

**참고 블로그 방식**:
- `transform.position`을 직접 변경
- 예: `transform.position += Vector3.left` - 왼쪽으로 이동
- 간단하고 직관적

**이 블로그 방식**:
- ✅ 참고 블로그 방식과 동일하게 `transform.position` 직접 변경
- ✅ `Vector3.left`, `Vector3.right`, `Vector3.down` 사용
- ✅ `ValidMove()`로 충돌 검사 후 이동

---

### 5. 현재 블록 찾기

**참고 블로그 방식**:
- 매번 `FindObjectOfType<Tetromino>()` 호출
- 간단하지만 매 프레임마다 검색하므로 조금 느릴 수 있음

**이 블로그 방식**:
- 한 번 찾아서 변수에 저장
- 저장된 변수를 재사용
- 더 빠르고 효율적

**왜 이렇게 하나요?**
- 참고 블로그: 간단하게 매번 찾기
- 이 블로그: 성능 최적화를 위해 한 번만 찾아서 재사용

---

## 📐 GameBoard 관련 차이점

### 6. GameBoard GameObject 위치

**블로그 설명**: 이해를 돕기 위해 간단하게 설명합니다.

**실제 구현**:
- GameBoard GameObject의 Transform 위치는 Unity 씬에서 설정하는 값입니다
- 게임 보드의 **논리적 좌표계**는 항상 (0, 0)부터 시작합니다
- Unity **월드 좌표계**에서는 GameBoard GameObject의 위치에 따라 달라질 수 있습니다
- **중요**: 웹사이트 기반 가이드에서는 GameBoard의 Unity 월드 좌표가 (0, 0, 0)이 아닐 수 있습니다
  - 예: Spawner 위치가 (5, 17, 0)으로 설정되는 경우가 많습니다
  - GameBoard의 실제 Unity 월드 좌표는 씬 설정에 따라 다를 수 있습니다
  - 하지만 **논리적 좌표계**는 항상 (0, 0)부터 시작하므로, Unity 월드 좌표와는 별개입니다

**차이점**:
- 블로그: 간단한 설명 (Unity 월드 좌표는 씬에서 설정)
- 실제: Unity 씬에서 설정 가능하며, 논리적 좌표와 월드 좌표는 별개입니다
- **중요**: 
  - 논리적 좌표 (0, 0)은 게임 보드의 왼쪽 아래 모서리를 의미합니다 (항상 동일)
  - Unity 월드 좌표는 GameBoard GameObject의 Transform 위치에 따라 달라집니다
  - **블로그에서 "(0, 0, 0)으로 맞춘다"고 설명하지만, 실제로는 Unity 씬에서 원하는 위치로 설정할 수 있으며, (0, 0, 0)이 아닐 수도 있습니다**

---

## 💡 왜 이런 차이가 있나요?

### 참고 블로그 (웹사이트 기반 가이드)의 특징
- **초보자 친화적**: 가장 간단한 방식으로 설명
- **직관적**: Unity 좌표를 직접 사용하여 이해하기 쉬움
- **빠른 시작**: 복잡한 개념 없이 바로 시작 가능
- **좌표 처리**: Mathf.RoundToInt()로 소수점을 정수로 변환

### 이 블로그의 특징
- **더 정확한 방식**: 논리적 좌표와 Unity 좌표 분리
- **확장 가능**: 나중에 기능 추가하기 쉬움
- **안전한 로직**: 충돌 검사와 롤백 기능 포함
- **성능 최적화**: 효율적인 알고리즘 사용

**어떤 방식을 선택해야 하나요?**
- 처음 배우는 중학생: 참고 블로그 방식이 더 쉬움
- 더 정확한 게임을 만들고 싶다면: 이 블로그 방식 추천

---

## 📖 더 알아보기

이 블로그의 방식에 대해 더 자세히 알고 싶다면:

1. **참고 자료**
   - [시스템 설계 개요](../참고자료/시스템설계개요.md) - 전체 구조 이해
   - [프로그램 처리 흐름](../참고자료/프로그램처리흐름설계.md) - 게임 흐름 이해
   - [좌표 처리 가이드](../참고자료/좌표처리-간단가이드.md) - 좌표 처리 방법

2. **참고 블로그 방식이 궁금하다면**
   - 웹사이트 기반 학습 가이드를 참고하세요
   - 좌표 처리를 단순화한 방식으로 설명되어 있습니다

---

## ✅ 정리

| 항목           | 참고 블로그 방식 (웹사이트 가이드) | 이 블로그 방식                     |
| -------------- | ---------------------------------- | ---------------------------------- |
| 블록 생성      | Unity에서 프리팹 직접 만들기       | ✅ 동일 - 프리팹 기반               |
| 자료구조       | 2차원 배열만 사용                  | ✅ 동일 - Dictionary/List 불필요    |
| 좌표계         | Unity 월드 좌표 직접 사용          | ✅ 동일 - Unity 좌표 직접 사용      |
| 좌표 변환      | Mathf.RoundToInt() 사용            | ✅ 동일 - Mathf.RoundToInt() 사용   |
| 이동 함수      | transform.position 직접 변경       | ✅ 동일 - transform.position 변경   |
| 자식 블록 접근 | transform.GetChild() 사용          | ✅ 동일 - transform.GetChild() 사용 |
| 블록 찾기      | 매번 FindObjectOfType 호출         | ✅ 동일 - FindObjectOfType 사용     |

**결론**: 이 블로그는 참고 블로그 방식과 동일하게 프리팹 기반, 2차원 배열 중심의 간단한 방식을 사용합니다!

---

[← 홈으로](./../index.md)
