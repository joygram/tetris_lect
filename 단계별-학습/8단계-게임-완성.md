---
layout: default
title: 8단계 - 게임 완성
---

# 8단계: 게임 완성

## 🎯 이 단계에서 배울 것

- Spawner 클래스 구현
- 게임 루프 완성
- 하드 드롭 기능
- 게임 오버 감지

---

## 🔷 구분하기: 내가 만드는 것 vs 엔진(API)이 주는 것

| 구분                    | 이번 단계 예시                                                                                | 설명                                                                                                                                                  |
| ----------------------- | --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **내가 만드는 것**      | **Spawner** 클래스, **SpawnNext()**, "언제 다음 블록을 만들지", "언제 게임 오버인지"          | 우리가 정의하는 **게임 흐름**: 블록 생성 타이밍, 게임 오버 조건. **규칙**은 전부 우리 로직.                                                           |
| **엔진(API)이 주는 것** | **Instantiate**, **Random.Range**, **Time.timeScale**, **FindObjectOfType**, **GetComponent** | Unity가 제공. **오브젝트 복제(Instantiate)**, **랜덤 수**, **시간 멈춤(Time.timeScale)** 은 엔진 기능. 우리는 "**무엇을**, **언제** 생성할지"만 정함. |

**왜 엔진 것을 쓰나?**  
씬에 오브젝트를 **실제로 만드는 것**은 **Instantiate** 라는 엔진 API가 합니다. 우리는 "**어떤 프리팹을**, **어디에** 만들지"만 인자로 넘깁니다. **Random.Range**는 엔진이 주는 "랜덤 수", **Time.timeScale = 0**은 "게임 시간 멈춤"을 엔진에 요청하는 것입니다. **우리 확장 영역**은 "언제 SpawnNext를 부를지, 언제 게임 오버로 볼지"이고, **나머지는 엔진을 호출해서 쓰는 것**입니다.

---

## 📝 실습 내용

**💡 8단계가 끝나면 플레이 가능한 테트리스가 됩니다.**  
Spawner 확장(랜덤·게임 오버) → LockPiece 연동 확인 → 하드 드롭 → 게임 오버 처리 순서로 되어 있습니다. 한 번에 다 안 해도, "다음 블록이 나온다"만 되면 일단 성공이라고 보면 됩니다.

---

**📌 작업 씬 제차 확인 (매 단계 필수)**  
이번 단계 실습을 시작하기 전에 **다시 한 번** 확인하세요. **상단 씬 탭**에서 지금 열린 씬이 **Tetris** (게임용)인지 봅니다. **Tetris가 아니면** (SimpleScene, SampleScene, Untitled 등) **반드시 Tetris로 이름을 변경**한 뒤 진행하세요. → 1단계 **[씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)**

**📌 8단계 시작 전 점검 (7·6·입력)**  
8단계는 **Spawner 확장 + 하드 드롭 + 게임 오버**만 붙이는 단계라서, 아래가 되어 있으면 편합니다.

| 확인 항목                | 설명                                                                                                   |
| ------------------------ | ------------------------------------------------------------------------------------------------------ |
| **5단계 입력**           | 키보드로 블록 이동·회전 되나요? → [5단계 - 입력 처리](./5단계-입력-처리.md)                            |
| **6단계 행 제거**        | 줄이 꽉 차면 줄이 사라지고 다음 블록이 나오나요? → [6단계 - 행 제거 시스템](./6단계-행-제거-시스템.md) |
| **7단계 GameController** | 점수·줄·레벨이 화면에 나오나요? → [7단계 - 점수·레벨 시스템](./7단계-점수-레벨-시스템.md)              |

위가 대략 되었다면 8단계는 **Spawner 코드 교체 → HardDrop → IsGameOver** 순서로 하면 됩니다.

---

### 1. Spawner 확장 (4단계에서 점증적 도입 → 8단계에서 완성)

**4단계**에서 이미 **Spawner**를 도입했고, Start에서 블록 한 개만 생성했습니다. **8단계**에서는 같은 Spawner에 아래를 **추가**합니다.

- **프리팹 배열** (`tetrisBlockPrefabs`) — 7가지 블록 중 하나 선택
- **Random.Range** — 랜덤 선택
- **게임 오버 확인** — GameBoard.IsGameOver(), 생성 위치 충돌 시 Time.timeScale = 0
- **LockPiece에서 SpawnNext() 호출** — 블록 고정 후 다음 블록 생성 (6단계에서 연결)

**4단계 Spawner가 없다면** 먼저 [4단계 - 블록 이동 구현](./4단계-블록-이동-구현.md)의 **0. Spawner 점증적 도입**을 따라 Spawner.cs를 만든 뒤, 아래 코드로 **교체**하세요.

**4단계에서 Spawner를 이미 만들었다면** `Spawner.cs`를 아래 코드로 **교체**합니다 (blockPrefab → tetrisBlockPrefabs 배열, SpawnNext()에 랜덤·게임오버 추가):

`Assets/Scripts/Spawner.cs`:

```csharp
using UnityEngine;

public class Spawner : MonoBehaviour   // [MonoBehaviour 상속]
{
    public GameObject[] tetrisBlockPrefabs;   // [우리 멤버] Inspector에서 7개 연결
    public Transform spawnPoint;               // [우리 멤버] Inspector에서 연결 — Transform은 Unity 타입

    private GameBoard gameBoard;       // [우리 멤버]
    private GameController gameController;   // [우리 멤버]

    void Start()   // [Unity가 호출] 상속받은 메소드 — 엔진이 한 번 호출
    {
        gameBoard = FindObjectOfType<GameBoard>();   // [Unity API]
        gameController = FindObjectOfType<GameController>();
        SpawnNext();   // [우리 메소드]
    }

    public void SpawnNext()   // [우리 메소드] 6단계 LockPiece에서 호출
    {
        if (gameBoard != null && gameBoard.IsGameOver())   // gameBoard: [우리 멤버], IsGameOver: [우리 메소드] GameBoard 쪽
        {
            Debug.Log("Game Over!");   // [Unity API]
            Time.timeScale = 0;   // [Unity 프로퍼티] 0이면 게임 시간 일시정지
            return;
        }
        int randomIndex = Random.Range(0, tetrisBlockPrefabs.Length);   // Random.Range: [Unity API], tetrisBlockPrefabs: [우리 멤버]
        GameObject newBlock = Instantiate(   // Instantiate: [Unity API]
            tetrisBlockPrefabs[randomIndex],
            spawnPoint != null ? spawnPoint.position : new Vector3(5f, 18f, 0f),   // spawnPoint: [우리 멤버], position: [Unity 프로퍼티]
            Quaternion.identity
        );
        TetrisBlock block = newBlock.GetComponent<TetrisBlock>();   // GetComponent: [Unity API]
        if (block != null && !block.ValidMove(Vector3.zero))   // ValidMove: [우리 메소드] TetrisBlock 쪽
        {
            Debug.Log("Game Over!");
            Time.timeScale = 0;
        }
    }
}
```

**📌 복기**: `tetrisBlockPrefabs` 는 **배열**(같은 타입 GameObject를 순서대로). 한 번에 이해 못했어도 [배열](../참고자료/개념/배열.md)에서 다시 실습해 보세요.

**Unity 에디터에서 설정** (위치 표기: [1단계 - 위치 표기 규칙](./1단계-Unity-기초.md#location-tree-notation)):
1. **4단계에서 Spawner를 만들었다면** **[Hierarchy > Spawner]** 그대로 사용. **안 만들었다면** **[Hierarchy]** 빈 공간 **우클릭** → **Create Empty** → 이름 **Spawner** → **[Project > Assets > Scripts > Spawner.cs]** 를 **[Hierarchy > Spawner]** 위로 **드래그**하여 스크립트 추가
2. **[Hierarchy > Spawner]** 클릭 → **[Inspector > Spawner (Script)]**:
   - **Tetris Block Prefabs**: 배열 크기 **7** (4단계에서 1개만 썼다면 **1**로 두고 나중에 7로 늘려도 됨)
   - 각 슬롯에 **[Project > Assets > Prefabs > I_Block]**, O_Block, T_Block, S_Block, Z_Block, J_Block, L_Block 할당
   - **Spawn Point**: **[Hierarchy > SpawnPoint]** 를 드래그하여 연결 (4단계에서 만든 SpawnPoint 그대로 사용)

### 2. TetrisBlock의 LockPiece 확인

6단계에서 이미 `LockPiece()` 함수에 Spawner 연결을 추가했습니다. 확인해보세요:

```csharp
// TetrisBlock.cs의 LockPiece() 함수에서
Spawner spawner = FindObjectOfType<Spawner>();
if (spawner != null)
{
    spawner.SpawnNext();
}
```

이미 구현되어 있다면 추가 작업이 필요 없습니다!

### 3. 하드 드롭 기능 구현

**📌 코드에서 쓰는 것 구분**  
- **우리 구현**: `HardDrop()`, `ValidMove()`, `LockPiece()`  
- **Unity 프로퍼티**: `transform.position` — Transform이 가진 위치 값. 괄호 없이 읽고 씁니다.

---

`TetrisBlock.cs`에 추가:

```csharp
public void HardDrop()   // [우리 구현] 한 번에 바닥까지 내리기
{
    while (ValidMove(Vector3.down))   // ValidMove: [우리 구현]
    {
        transform.position += Vector3.down;   // transform, position: [Unity 프로퍼티]
    }
    LockPiece();   // [우리 구현] 6단계에서 만든 고정 + 행 제거
}
```

`InputHandler.cs`에 추가:

```csharp
void Update()
{
    // ... 기존 코드 ...
    if (Input.GetKeyDown(KeyCode.Space))   // Input.GetKeyDown, KeyCode: [Unity API]
    {
        TetrisBlock current = FindObjectOfType<TetrisBlock>();   // [Unity API]
        if (current != null) current.HardDrop();   // HardDrop: [우리 구현]
    }
}
```

---

### 4. 게임 오버 감지

**📌** `IsGameOver()`는 **우리가 구현**하는 함수입니다. Spawner에서 "다음 블록 생성 전"에 한 번 호출해서, 상단 행이 이미 막혀 있으면 게임 오버로 처리합니다.

---

`GameBoard.cs`에 게임 오버 확인 함수 추가:

```csharp
public bool IsGameOver()   // [우리 메소드] Spawner에서 호출
{
    for (int x = 0; x < width; x++)   // width: [우리 멤버]
    {
        if (grid[x, height - 1] != null)   // grid, height: [우리 멤버]
            return true;
    }
    return false;
}
```

**또는 Spawner에서 생성 시 확인**:

```csharp
// Spawner.cs의 SpawnNext() 함수에서
public void SpawnNext()
{
    // 게임 오버 확인
    if (gameBoard != null && gameBoard.IsGameOver())
    {
        Debug.Log("Game Over!");
        Time.timeScale = 0;  // 게임 일시정지
        return;
    }
    
    // ... 블록 생성 코드 ...
    
    // 생성된 블록이 이미 충돌하는지 확인
    TetrisBlock newBlock = newBlock.GetComponent<TetrisBlock>();
    if (newBlock != null)
    {
        // 생성 위치에 이미 블록이 있으면 게임 오버
        if (!newBlock.ValidMove(Vector3.zero))
        {
            Debug.Log("Game Over!");
            Time.timeScale = 0;
        }
    }
}
```

## 🔗 이전 단계와의 연결

**이 섹션은 실습이 아닙니다.** 따로 할 일이나 체크할 항목은 없습니다. "이 단계가 이전 단계와 어떻게 이어지는지"만 **참고**로 정리한 것이므로, 궁금할 때만 읽으면 됩니다.

이 단계에서는 모든 이전 단계의 기능을 연결합니다:
- **2단계 GameBoard**: 게임 오버 확인
- **3단계 TetrisBlock**: 블록 생성 및 초기화
- **4단계 이동/회전**: 블록 제어
- **5단계 InputHandler**: 하드 드롭 입력 처리
- **6단계 행 제거**: 블록 고정 후 행 제거
- **7단계 GameController**: 점수 계산

**완전한 게임 루프**:
1. Spawner가 새 블록 생성
2. InputHandler가 입력 처리 (이동, 회전, 하드 드롭)
3. 블록이 자동으로 낙하
4. 블록이 바닥에 닿으면 고정
5. 행 제거 및 점수 계산
6. 다음 블록 생성
7. 게임 오버 확인

## 💡 지금까지 익힌 개념 정리

- **Awake** = 가장 먼저 한 번 (준비), **Start** = 한 번 (시작), **Update** = 매 프레임 반복
- **멤버** = 클래스 안의 변수(저장소), **메소드** = 클래스 안의 함수(그 저장소를 다루는 일)
- **클래스** = 멤버 + 메소드를 한 덩어리로 묶은 것

**📌 복기**: **변수**(멤버) + **메소드**. 한 번에 이해 못했어도 [변수](../참고자료/개념/변수.md) · [멤버와 메소드](../참고자료/개념/멤버와메소드.md)에서 다시 실습해 보세요.

## 📖 기초 개념 학습 (복기 → 점진적 실습)

**📌 복기**로 위 개념을 떠올린 뒤, 아래 **기초 개념** 문서에서 **점진적으로 확장된 실습**을 진행하세요. 게임이 완성된 뒤에도 같은 개념이 단계별로 확장되므로, 차근차근 따라 하면 복습이 됩니다.

| 개념 문서                                                        | 연결                                               |
| ---------------------------------------------------------------- | -------------------------------------------------- |
| [MonoBehaviour](../참고자료/개념/MonoBehaviour.md)               | Awake / Start / Update 용도·실행 순서 실습         |
| [멤버와 메소드](../참고자료/개념/멤버와메소드.md)                | 멤버·메소드 한눈에 + AddScore 실습                 |
| [Instantiate / Destroy](../참고자료/개념/Instantiate-Destroy.md) | Spawner가 블록 생성·삭제. 프리팹 복제·Destroy 실습 |
| [게임 루프](../참고자료/개념/게임루프.md)                        | 게임이 도는 흐름. Update 반복 실습                 |
| [개념 설명 (목차)](../참고자료/개념설명.md)                      | 모든 개념 문서 한눈에                              |

**📐 이 단계 확장 실습** (전용 씬에서 점진적 연습): [8단계 확장 실습 01 - Instantiate와 Random](../참고자료/확장-실습/8단계/01-Instantiate와Random.md)  
→ 단계별 확장 실습 전체 목차: [단계별 확장 실습 (목차)](../참고자료/확장-실습/README.md)

## ✅ 확인 사항

- [ ] 새로운 블록이 자동으로 생성되는가?
- [ ] 블록 고정 후 다음 블록이 생성되는가?
- [ ] 게임 오버가 감지되는가?
- [ ] 하드 드롭이 작동하는가?
- [ ] 행 제거 후 점수가 올라가는가?
- [ ] 완전히 작동하는 테트리스 게임인가?

## 🎉 완성!

축하합니다! 테트리스 게임을 완성했습니다!  
(게임 오버가 나와도 "로직이 동작한다"는 뜻이니, 그때는 **반성공**이라고 생각해도 됩니다. 😄)

## 🚀 개선 아이디어

- 다음 조각 미리보기
- 홀드 기능
- 사운드 효과
- 파티클 효과
- 하이스코어 저장

**✅ 게임 완성 후**: 작업 씬이 **Tetris**인지 **재차 확인**해 두면, 나중에 프로젝트를 다시 열었을 때 혼란이 없습니다. Tetris가 아니면 [씬 이름 변경 방법](./1단계-Unity-기초.md#scene-rename-guide)을 따라 Tetris로 바꾸세요.

---

[← 이전 단계: 7단계 - 점수 및 레벨 시스템](./7단계-점수-레벨-시스템.md)
